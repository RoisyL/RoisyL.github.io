<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>BUAA-OS-Lab4_challenge sigaction实现 | Roisy's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="https://s2.loli.net/2025/03/01/MF8SBrfc2xnP9Qb.jpg"><link rel="Shortcut Icon" type="image/x-icon" href="https://s2.loli.net/2025/03/01/MF8SBrfc2xnP9Qb.jpg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">BUAA-OS-Lab4_challenge sigaction实现</h1><a id="logo" href="/.">Roisy's Blog</a><p class="description">一个SE学生的自留地</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">BUAA-OS-Lab4_challenge sigaction实现</h1><div class="post-meta">2024-08-29<span> | </span><span class="category"><a href="/categories/BUAA-SE/">BUAA-SE</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 20</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#sigaction%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">sigaction简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">任务描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%AE%8F%E7%AD%89%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">数据结构、宏等设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">信号相关设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Env%E7%BB%93%E6%9E%84%E4%BD%93%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98"><span class="toc-number">3.2.</span> <span class="toc-text">Env结构体添加成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">错误返回值设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">3.4.</span> <span class="toc-text">头文件中添加相关函数声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%89%8D%E7%BD%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">初始化与全局变量设置相关前置操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">新增相关系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">统一流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%89%80%E9%9C%80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">新增功能实现所需系统调用的具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">信号处理流程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="toc-number">6.1.</span> <span class="toc-text">信号处理的触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%91%E9%80%81%E8%A7%A6%E5%8F%91"><span class="toc-number">6.2.</span> <span class="toc-text">各类信号的发送触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E9%80%81"><span class="toc-number">6.3.</span> <span class="toc-text">信号的注册与发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">6.4.</span> <span class="toc-text">信号检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%AE%9E%E9%99%85%E5%A4%84%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">信号的实际处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%90%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.6.</span> <span class="toc-text">信号处理后上下文的信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">信号集处理函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BF%AE%E6%94%B9%EF%BC%88%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">其他修改（踩过的坑）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8Trapframe%E4%BF%9D%E5%AD%98%E4%B8%8E%E4%BC%A0%E9%80%92%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.1.</span> <span class="toc-text">寄存器Trapframe保存与传递设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E6%97%B6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">8.2.</span> <span class="toc-text">fork时相关设置的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E7%9A%84%E5%90%8C%E6%AD%A5%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.3.</span> <span class="toc-text">页错误处理函数入口的同步设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">其他踩过的坑&#x2F;关键设计</span></a></li></ol></div></div><div class="post-content"><h2 id="sigaction简介"><a href="#sigaction简介" class="headerlink" title="sigaction简介"></a><strong>sigaction简介</strong></h2><p><font color="green">当一个信号被发送给一个进程时</font>, 内核会中断进程的正常控制流，转而<strong>执行与该信号相关的用户态处理函数</strong>进行处理</p>
<p>在<font color="green">执行该处理函数前</font>，会<font color="blue">将该信号所设置的信号屏蔽集加入到进程的信号屏蔽集</font>中，在<font color="green">执行完该用户态处理函数后</font>，又会<font color="blue">将恢复原来的信号屏蔽集</font></p>
<h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a><strong>任务描述</strong></h2><p><code>sigaction</code>结构体用于设置<font color="red"><strong>所需要处理的信号集及其对应的处理函数</strong></font></p>
<p><code>sigset_t</code>使用<font color="red"><strong>32位</strong></font>表示MOS所需要处理的<font color="red"><strong>[1,32]信号掩码</strong>，对应位为<strong>1表示阻塞</strong>，为0表示未被阻塞</font></p>
<p><code>sigset_t</code>与<code>sigaction</code>结构体定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigset_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> sig;</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>); <span class="comment">//信号的处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构、宏等设计"><a href="#数据结构、宏等设计" class="headerlink" title="数据结构、宏等设计"></a>数据结构、宏等设计</h2><h3 id="信号相关设置"><a href="#信号相关设置" class="headerlink" title="信号相关设置"></a>信号相关设置</h3><p>此处挂起信号队列<font color='blue'>沿用此前MOS中设计的<strong>TAILQ结构</strong>并使用相关函数</font>，实现参考 <code>kern\env.c</code> 中<code>env_sched_list</code> 相关部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/signal.h</span></span><br><span class="line"><span class="comment">// 信号掩码控制宏 __how的取值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_BLOCK (0)	<span class="comment">// 添加__set到当前掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_UNBLOCK (1) <span class="comment">// 从当前掩码中移除__set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_SETMASK (2) <span class="comment">// 设置当前掩码为__set</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGNUM编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGINT (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGILL (4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGKILL (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSEGV (11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGCHLD (17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSYS (31)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_MAX (32) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 掩码结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigset_t</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> sig;</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号操作结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*sa_handler)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> &#123;</span></span><br><span class="line">	TAILQ_ENTRY(signal) sig_link;</span><br><span class="line">	<span class="type">int</span> signum;</span><br><span class="line">	<span class="type">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起的信号队列</span></span><br><span class="line">TAILQ_HEAD(Sig_pend_list, signal);</span><br></pre></td></tr></table></figure>

<h3 id="Env结构体添加成员"><a href="#Env结构体添加成员" class="headerlink" title="Env结构体添加成员"></a>Env结构体添加成员</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="comment">// lab4-challenge</span></span><br><span class="line">	u_int env_user_sighand_entry;	<span class="comment">// 用户态信号处理函数入口</span></span><br><span class="line">	u_int now_sig_time;		<span class="comment">// 记录当前正在处理的信号的到达时间，重入处理的时候用</span></span><br><span class="line">	u_int is_handling_SIGKILL;		<span class="comment">// 判定现在正在被处理的是否是SIGKILL信号，若是则为1，反之为0</span></span><br><span class="line">	u_int sig_exist[<span class="number">32</span>];	<span class="comment">// 每种信号在当前进程的存在性判断，保证每种信号的唯一性</span></span><br><span class="line">	<span class="type">sigset_t</span> sig_blocked;	       <span class="comment">// 信号掩码</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Sig_pend_list</span> <span class="title">sig_pend_list</span>;</span>	<span class="comment">// 挂起信号队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sighand</span>[32];</span>  <span class="comment">// 信号注册数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="错误返回值设置"><a href="#错误返回值设置" class="headerlink" title="错误返回值设置"></a>错误返回值设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/error.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_SIG 1    <span class="comment">// 实际运用一般都是 return -E_SIG</span></span></span><br></pre></td></tr></table></figure>

<h3 id="头文件中添加相关函数声明"><a href="#头文件中添加相关函数声明" class="headerlink" title="头文件中添加相关函数声明"></a>头文件中添加相关函数声明</h3><p>由于没有太多技术含量，此处省略，在实现具体函数后到相应头文件中添加即可</p>
<h2 id="初始化与全局变量设置相关前置操作"><a href="#初始化与全局变量设置相关前置操作" class="headerlink" title="初始化与全局变量设置相关前置操作"></a>初始化与全局变量设置相关前置操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="type">int</span> sigsTime = <span class="number">1</span>;    <span class="comment">// 用于标记信号到达时间，越小则到达时间越早</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> <span class="title">signals</span>[<span class="title">SIG_MAX</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PAGE_SIZE</span>)));</span>    <span class="comment">// 进程信号数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line">	<span class="comment">// lab4-challenge</span></span><br><span class="line">	<span class="comment">// 最初都初始化为0</span></span><br><span class="line">	e-&gt;sig_blocked.sig = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_user_sighand_entry = <span class="number">0</span>;</span><br><span class="line">	e-&gt;sig_pend_cnt = <span class="number">0</span>;</span><br><span class="line">	e-&gt;now_sig_time = <span class="number">0</span>;</span><br><span class="line">	e-&gt;is_handling_SIGKILL = <span class="number">0</span>;</span><br><span class="line">	TAILQ_INIT(&amp;e-&gt;sig_pend_list);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">		e-&gt;sig_exist[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">		e-&gt;sighand[i].sa_handler = <span class="literal">NULL</span>;</span><br><span class="line">		e-&gt;sighand[i].sa_mask.sig = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新增相关系统调用"><a href="#新增相关系统调用" class="headerlink" title="新增相关系统调用"></a>新增相关系统调用</h2><h3 id="统一流程"><a href="#统一流程" class="headerlink" title="统一流程"></a>统一流程</h3><p>添加系统调用 <code>syscall_func(u_int envid, ......)</code>：</p>
<ol>
<li><p>在 <code>user/include/lib.h</code> 中添加 <code>void syscall_func(u_int envid, ......);</code></p>
</li>
<li><p>在 <code>user/lib/syscall_lib.c</code> 中添加</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_func</span><span class="params">(u_int envid, ......)</span> &#123; </span><br><span class="line">	......</span><br><span class="line">	msyscall(SYS_func, envid, ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>include/syscall.h</code> 中的 <code>enum</code> 的 <code>MAX_SYSNO</code> 前添加 <code>SYS_func,</code></p>
</li>
<li><p>在 <code>kern/syscall_all.c</code> 的 <code>void *syscall_table[MAX_SYSNO]</code> 中加上 <code>[SYS_func] = sys_func,</code> （注意与前一步的对应）</p>
</li>
<li><p>在 <code>kern/syscall_all.c</code> 的 <code>void *syscall_table[MAX_SYSNO]</code> 之间完成函数<br><code>void sys_func(u_int envid, ......);</code> 的具体实现</p>
</li>
</ol>
<h3 id="新增功能实现所需系统调用的具体实现"><a href="#新增功能实现所需系统调用的具体实现" class="headerlink" title="新增功能实现所需系统调用的具体实现"></a>新增功能实现所需系统调用的具体实现</h3><ul>
<li><p><code>sys_</code> 具体实现</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="comment">// 信号注册</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, </span></span><br><span class="line"><span class="params">														\<span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> *<span class="title">sig</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 只需考虑signum小于或等于32的情况,超出该范围返回-1</span></span><br><span class="line">	<span class="keyword">if</span> (signum &lt; <span class="number">1</span> || signum &gt; SIG_MAX) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	e = curenv;</span><br><span class="line">	sig = &amp;e-&gt;sighand[signum - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (oldact) &#123;</span><br><span class="line">		*oldact = *sig;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (newact) &#123;</span><br><span class="line">		*sig = *newact;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进程的信号处理函数入口地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sighand_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	env-&gt;env_user_sighand_entry = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向进程发送信号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sigsTime;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">signal</span> <span class="title">signals</span>[<span class="title">SIG_MAX</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PAGE_SIZE</span>)));</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sendsig</span><span class="params">(u_int envid, <span class="type">int</span> sig)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="comment">// 当envid对应进程不存在，或者sig不符合定义范围时，返回异常码-1</span></span><br><span class="line">	<span class="keyword">if</span> ( sig &lt; <span class="number">1</span> || sig &gt; SIG_MAX || envid2env(envid, &amp;e, <span class="number">0</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 当进程中已经有同种信号，则不再接收</span></span><br><span class="line">	<span class="keyword">if</span> ( e-&gt;sig_exist[sig<span class="number">-1</span>] == <span class="number">1</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将信号添加进对应进程的信号处理队列</span></span><br><span class="line">	signals[sig<span class="number">-1</span>].signum = sig;</span><br><span class="line">	signals[sig<span class="number">-1</span>].time = sigsTime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> signal *)(&amp;signals[sig<span class="number">-1</span>]);</span><br><span class="line">	e-&gt;sig_exist[sig<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">	TAILQ_INSERT_HEAD(&amp;e-&gt;sig_pend_list, (s), sig_link);</span><br><span class="line">	sigsTime++;</span><br><span class="line">	e-&gt;sig_pend_cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据__how的值更改当前进程的信号屏蔽字</span></span><br><span class="line"><span class="comment">// __set是要应用的新掩码，__oset（如果非NULL）则保存旧的信号屏蔽字</span></span><br><span class="line"><span class="comment">// __how可以是SIG_BLOCK（添加__set到当前掩码）、SIG_UNBLOCK（从当前掩码中移除__set）</span></span><br><span class="line"><span class="comment">//         或SIG_SETMASK（设置当前掩码为__set）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> * __set, <span class="type">sigset_t</span> * __oset)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="type">sigset_t</span> *sigset;</span><br><span class="line">	e = curenv;</span><br><span class="line">	sigset = &amp;e-&gt;sig_blocked;</span><br><span class="line">	<span class="keyword">if</span> (__oset!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		*__oset = *sigset;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (__set!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (__how) &#123;</span><br><span class="line">			<span class="keyword">case</span> SIG_BLOCK:</span><br><span class="line">				sigset-&gt;sig |= __set-&gt;sig;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SIG_UNBLOCK:</span><br><span class="line">				sigset-&gt;sig &amp;= ~__set-&gt;sig;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SIG_SETMASK:</span><br><span class="line">				sigset-&gt;sig = __set-&gt;sig;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> -E_SIG;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号__signo是否是__set信号集的成员。如果是，返回1；如果不是，返回0。</span></span><br><span class="line"><span class="type">int</span> _sigismember(<span class="type">const</span> <span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)&#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__signo -= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &amp; (__set-&gt;sig &gt;&gt; (__signo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前被阻塞且未处理的信号集，并将其存储在__set中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigpending</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="type">uint32_t</span> newSig = __set-&gt;sig;</span><br><span class="line">	TAILQ_FOREACH (s, &amp;curenv-&gt;sig_pend_list, sig_link) &#123;</span><br><span class="line">		<span class="comment">// 检查掩码</span></span><br><span class="line">		<span class="keyword">if</span> ( _sigismember(&amp;curenv-&gt;sig_blocked, s-&gt;signum) ) &#123;</span><br><span class="line">			t = s-&gt;signum;</span><br><span class="line">			newSig |= (<span class="number">1</span> &lt;&lt; (t<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__set-&gt;sig = newSig;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取进程状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_check_env_status</span><span class="params">(u_int envid)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">e</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分除 <code>msyscall</code> 还有其他操作的 <code>syscall_</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, </span></span><br><span class="line"><span class="params">																	\<span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (oldact) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(oldact, <span class="number">0</span>, <span class="keyword">sizeof</span>(oldact));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_sigaction, signum, newact, oldact);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> * __set, <span class="type">sigset_t</span> * __oset)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__oset) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(__oset, <span class="number">0</span>, <span class="keyword">sizeof</span>(__oset));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_sigprocmask, __how, __set, __oset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="信号处理流程实现"><a href="#信号处理流程实现" class="headerlink" title="信号处理流程实现"></a>信号处理流程实现</h2><h3 id="信号处理的触发"><a href="#信号处理的触发" class="headerlink" title="信号处理的触发"></a>信号处理的触发</h3><p>在 <code>ret_from_exception</code> 中加入跳转到 <code>do_signal</code> 的代码，<font color='red'>使得每次从用户态到内核态都调用一次信号检查函数</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// kern/genex.S</span><br><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">	// 加入跳转到do_signal的代码（每次从用户态到内核态都调用一次）</span><br><span class="line">		 move    a0, sp</span><br><span class="line">     addiu   sp, sp, -8</span><br><span class="line">     jal     do_signal</span><br><span class="line">     addiu   sp, sp, 8</span><br></pre></td></tr></table></figure>

<h3 id="各类信号的发送触发"><a href="#各类信号的发送触发" class="headerlink" title="各类信号的发送触发"></a>各类信号的发送触发</h3><ul>
<li><p><code>SIGINT</code> 与 <code>SIGKILL</code> 一般在程序中手动触发，不会直接在MOS代码中发送</p>
</li>
<li><p><code>SIGILL</code></p>
<p>  <em>发送契机</em> ：<font color='green'>在进行异常处理前，发现当前异常由<strong>非法指令</strong>引发</font>，向自身发送 <code>SIGILL</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/traps.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_reserved</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(((tf-&gt;cp0_cause &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x1f</span>) == <span class="number">10</span>)&#123;</span><br><span class="line">        sys_sendsig(<span class="number">0</span>, SIGILL);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SIGSEGV</code></p>
<p>  <em>发送契机</em> ：<font color='green'>当前地址过低不允许访问</font>，则向自身发送 <code>SIGSEGV</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/tlbex.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (va &lt; UTEMP) &#123;</span><br><span class="line">		<span class="comment">// panic(&quot;address too low&quot;);</span></span><br><span class="line">		sys_sendsig(curenv-&gt;env_id, SIGSEGV);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SIGCHLD</code></p>
<p>  <em>发送契机</em> ：<font color='green'>子进程退出时，若父进程仍在运行</font>，则子进程向父进程发送 <code>SIGCHLD</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">env_destroy</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">	<span class="comment">// lab4-challenge</span></span><br><span class="line">	<span class="keyword">if</span>( e-&gt;env_parent_id != <span class="number">0</span>)&#123;</span><br><span class="line">		sys_sendsig( e-&gt;env_parent_id, SIGCHLD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SIGSYS</code></p>
<p>  <em>发送契机</em> ：<font color='green'>当前系统调用号不存在时</font>，需要<font color='red'>先<strong>忽视（跳过）此条语句</strong></font>，再向自身发送 <code>SIGSYS</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">		tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">		sys_sendsig(curenv-&gt;env_id, SIGSYS);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信号的注册与发送"><a href="#信号的注册与发送" class="headerlink" title="信号的注册与发送"></a>信号的注册与发送</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, <span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line">	<span class="comment">// 确保设置好信号处理函数入口地址</span></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;env_user_sighand_entry != (u_int)sighand_entry) &#123;</span><br><span class="line">		try(syscall_set_sighand_entry(<span class="number">0</span>, (u_int)sighand_entry));</span><br><span class="line">		try(syscall_set_tlb_mod_entry(<span class="number">0</span>, (u_int)entry_wrapper));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> r = syscall_sigaction(signum, newact, oldact);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号发送函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(u_int envid, <span class="type">int</span> sig)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果sig为SIGCHLD,SIGILL,SIGSYS,SIGSEGV信号，返回异常码-1</span></span><br><span class="line">	<span class="keyword">if</span> (sig == SIGILL || sig == SIGSYS || sig == SIGCHLD || sig == SIGSEGV) &#123;</span><br><span class="line">		<span class="comment">// debugf(&quot;Only MOS can send SIGCHLD &amp; SIGILL &amp; SIGSYS &amp; SIGSEGV signal.\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确保设置好信号处理函数入口地址</span></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;env_user_sighand_entry != (u_int)sighand_entry) &#123;</span><br><span class="line">		try(syscall_set_sighand_entry(<span class="number">0</span>, (u_int)sighand_entry));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> r = syscall_sendsig(envid, sig);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号检查"><a href="#信号检查" class="headerlink" title="信号检查"></a>信号检查</h3><ul>
<li><code>do_signal</code> 实现对当前挂起信号队列的检查，选择合适的信号后<font color='red'>调用 <code>sig_setuptf</code> 跳转到信号处理函数入口并为其传递参数</font></li>
<li>保存寄存器上下文函数 <code>sig_setuptf</code> 参照 <code>kern\tlbex.c</code> 中 <code>do_tlb_mod</code> 实现，具体参数设计见后续信号处理函数入口</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_signal</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="comment">// 在为进程设置sigpri之前也可能会发生一些异常产生异常重入的现象</span></span><br><span class="line">	<span class="comment">// 而异常重入的时候不可能产生任何新的信号,没必要处理信号,直接return</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="type">int</span>)tf-&gt;cp0_epc)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果没有待处理信号，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (TAILQ_EMPTY(&amp;curenv-&gt;sig_pend_list))&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>, *s_min = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> signo = <span class="number">10000</span>;    <span class="comment">// 初始化为10000，后续用于判断当前信号优先级是否高于之前选中的信号</span></span><br><span class="line">	<span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从进程的队列中取出未被阻塞的signal</span></span><br><span class="line">	<span class="comment">// SIGKILL优先级最高</span></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;sig_exist[SIGKILL<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">,		TAILQ_FOREACH (s_min, &amp;curenv-&gt;sig_pend_list, sig_link) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s_min-&gt;signum == SIGKILL) &#123;</span><br><span class="line">				signo = s_min-&gt;signum;</span><br><span class="line">				time = s_min-&gt;time;</span><br><span class="line">				curenv-&gt;is_handling_SIGKILL = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(curenv-&gt;is_handling_SIGKILL == <span class="number">0</span>)&#123;</span><br><span class="line">		TAILQ_FOREACH (s, &amp;curenv-&gt;sig_pend_list, sig_link) &#123;</span><br><span class="line">			<span class="comment">// 如果当前有信号正在处理且此信号比当前信号到达时间早，则break</span></span><br><span class="line">			<span class="keyword">if</span> ( s-&gt;time &lt;= curenv-&gt;now_sig_time )&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 选取优先级最高的</span></span><br><span class="line">			<span class="keyword">if</span> ( s-&gt;signum &lt; signo </span><br><span class="line">						&amp;&amp; ( (curenv-&gt;sig_blocked.sig &amp; (<span class="number">1</span>&lt;&lt;(s-&gt;signum<span class="number">-1</span>))) == <span class="number">0</span> ))&#123;</span><br><span class="line">				signo = s-&gt;signum;</span><br><span class="line">				time = s-&gt;time;</span><br><span class="line">				s_min = s;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若存在未被阻塞的signal, 则修改进程上下文, 转到用户态的信号处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (s_min) &#123;</span><br><span class="line">		curenv-&gt;now_sig_time = time;</span><br><span class="line">		curenv-&gt;sig_exist[signo<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		TAILQ_REMOVE(&amp;curenv-&gt;sig_pend_list, s_min, sig_link);</span><br><span class="line">		<span class="comment">// 保存寄存器上下文，给信号处理函数传递参数</span></span><br><span class="line">		sig_setuptf(tf, signo);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存寄存器上下文（仿写do_tlb_mod）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_setuptf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf, <span class="type">int</span> signum)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">	&#125;</span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">	*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line">	<span class="comment">// 将信号处理需要传递的相关参数保存至异常现场栈中</span></span><br><span class="line">	tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">	tf-&gt;regs[<span class="number">5</span>] = signum;</span><br><span class="line">	tf-&gt;regs[<span class="number">6</span>] = (<span class="type">unsigned</span> <span class="type">int</span>)(curenv-&gt;sighand[signum<span class="number">-1</span>].sa_handler);</span><br><span class="line">	<span class="type">uint32_t</span> newMask = <span class="number">0</span>;</span><br><span class="line">	newMask = curenv-&gt;sighand[signum<span class="number">-1</span>].sa_mask.sig | curenv-&gt;sig_blocked.sig </span><br><span class="line">																									\ | (<span class="number">1</span> &lt;&lt; (signum - <span class="number">1</span>)) ;</span><br><span class="line">	tf-&gt;regs[<span class="number">7</span>] = (<span class="type">uint32_t</span>)newMask;</span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">5</span>]);</span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">6</span>]);</span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">7</span>]);</span><br><span class="line">	tf-&gt;cp0_epc = curenv-&gt;env_user_sighand_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号的实际处理"><a href="#信号的实际处理" class="headerlink" title="信号的实际处理"></a>信号的实际处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行信号</span></span><br><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sighand_entry(<span class="keyword">struct</span> Trapframe *tf, <span class="type">int</span> signum, </span><br><span class="line">																	\	<span class="type">void</span> (*sa_handler)(<span class="type">int</span>), <span class="type">uint32_t</span> newMask) &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// 若设置了处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (sa_handler &amp;&amp; signum != SIGKILL ) &#123;</span><br><span class="line">		<span class="comment">// 处理前修改进程掩码</span></span><br><span class="line">		<span class="type">sigset_t</span> oldSigset=&#123;<span class="number">0</span>&#125;, newSigset=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		newSigset.sig = newMask;</span><br><span class="line">		r= syscall_sigprocmask(<span class="number">2</span>, (<span class="type">sigset_t</span> *)&amp;newSigset, (<span class="type">sigset_t</span> *)&amp;oldSigset);</span><br><span class="line">		sa_handler(signum);</span><br><span class="line">		<span class="comment">// 恢复进程原掩码</span></span><br><span class="line">		syscall_sigprocmask(<span class="number">2</span>, (<span class="type">sigset_t</span> *)&amp;oldSigset, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 恢复上下文</span></span><br><span class="line">		r = syscall_set_sig_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">		user_panic(<span class="string">&quot;sig_entry syscall_set_sig_trapframe returned %d&quot;</span>, r);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">switch</span> (signum) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGINT: <span class="keyword">case</span> SIGILL: <span class="keyword">case</span> SIGKILL: <span class="keyword">case</span> SIGSEGV: </span><br><span class="line">				<span class="comment">// 退出用exit</span></span><br><span class="line">            <span class="built_in">exit</span>(); </span><br><span class="line">            user_panic(<span class="string">&quot;sig_entry syscall_env_destroy returned&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            r = syscall_set_sig_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">            user_panic(<span class="string">&quot;sig_entry syscall_set_sig_trapframe returned %d&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="信号处理后上下文的信号"><a href="#信号处理后上下文的信号" class="headerlink" title="信号处理后上下文的信号"></a>信号处理后上下文的信号</h3><p>参考同文件中的 <code>sys_set_trapframe</code> 实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig_trapframe</span><span class="params">(u_int envid, <span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range((u_long)tf, <span class="keyword">sizeof</span> *tf)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 当前信号处理完毕，故重置 env-&gt;now_sig_time 为 0</span></span><br><span class="line">	env-&gt;now_sig_time = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (env == curenv) &#123;</span><br><span class="line">		*((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>) = *tf;</span><br><span class="line">		<span class="comment">// return `tf-&gt;regs[2]` instead of 0, because return value overrides regs[2] on</span></span><br><span class="line">		<span class="comment">// current trapframe.</span></span><br><span class="line">		<span class="keyword">return</span> tf-&gt;regs[<span class="number">2</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		env-&gt;env_tf = *tf;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号集处理函数实现"><a href="#信号集处理函数实现" class="headerlink" title="信号集处理函数实现"></a>信号集<strong>处理函数实现</strong></h2><p>注意如果<font color='green'>传入参数不合法</font>，返回值为 <code>-E_SIG</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"><span class="comment">// 计算两个信号集__left和__right的并集，并将结果存储在__set中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigorset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">const</span> <span class="type">sigset_t</span> *__left, <span class="type">const</span> <span class="type">sigset_t</span> *__right)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __left == <span class="literal">NULL</span> ||  __right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	__set-&gt;sig = __left-&gt;sig | __right-&gt;sig;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据__how的值更改当前进程的信号屏蔽字。__set是要应用的新掩码</span></span><br><span class="line"><span class="comment">// __oset（如果非NULL）则保存旧的信号屏蔽字</span></span><br><span class="line"><span class="comment">// __how可以是SIG_BLOCK（添加__set到当前掩码）、SIG_UNBLOCK（从当前掩码中移除__set）</span></span><br><span class="line"><span class="comment">//   或SIG_SETMASK（设置当前掩码为__set）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> * __set, <span class="type">sigset_t</span> * __oset)</span>&#123;</span><br><span class="line">	syscall_sigprocmask(__how, __set, __oset);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空参数中的__set掩码，初始化信号集以排除所有信号。这意味着__set将不包含任何信号。(清0)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__set-&gt;sig = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数中的__set掩码填满，使其包含所有已定义的信号。这意味着__set将包括所有信号。(全为1)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	sigemptyset(__set);</span><br><span class="line">	__set-&gt;sig = ~(__set-&gt;sig);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向__set信号集中添加一个信号__signo。如果操作成功，__set将包含该信号。(置位为1)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( __signo &lt; <span class="number">1</span> || __signo &gt; SIG_MAX ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;;</span><br><span class="line">	__set-&gt;sig |= (<span class="number">1</span>&lt;&lt;(__signo<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从__set信号集中删除一个信号__signo。如果操作成功，__set将不再包含该信号。(置位为0)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( __signo &lt; <span class="number">1</span> || __signo &gt; SIG_MAX ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;;</span><br><span class="line">	__set-&gt;sig &amp;= ~(<span class="number">1</span>&lt;&lt;(__signo<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号__signo是否是__set信号集的成员。如果是，返回1；如果不是，返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &amp; (__set-&gt;sig &gt;&gt; (__signo<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号集__set是否为空。如果为空，返回1；如果不为空，返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigisemptyset</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __set-&gt;sig == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个信号集__left和__right的交集，并将结果存储在__set中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigandset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">const</span> <span class="type">sigset_t</span> *__left, <span class="type">const</span> <span class="type">sigset_t</span> *__right)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __left == <span class="literal">NULL</span> ||  __right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	__set-&gt;sig = __left-&gt;sig &amp; __right-&gt;sig;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前被阻塞且未处理的信号集，并将其存储在__set中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_SIG;</span><br><span class="line">	&#125;</span><br><span class="line">	syscall_sigpending( __set);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他修改（踩过的坑）"><a href="#其他修改（踩过的坑）" class="headerlink" title="其他修改（踩过的坑）"></a>其他修改（踩过的坑）</h2><h3 id="寄存器Trapframe保存与传递设置"><a href="#寄存器Trapframe保存与传递设置" class="headerlink" title="寄存器Trapframe保存与传递设置"></a>寄存器Trapframe保存与传递设置</h3><p>当 <code>env_pop_tf</code> 函数被调用时，它会将 <code>curenv-&gt;env_tf</code>（即当前进程的上下文）加载到处理器寄存器中，并且将 <code>curenv-&gt;env_tf</code> 的地址赋值给堆栈指针 <code>sp</code>。进入 <code>do_signal</code> 函数时，堆栈指针 <code>sp</code> 指向 <code>curenv-&gt;env_tf</code> 的位置。</p>
<p>假设 <code>do_signal</code> 函数会在其执行过程中使用堆栈保存临时数据和函数调用信息，则<font color='red'>这些数据会<strong>覆盖</strong> <code>curenv-&gt;env_tf</code> 的内容，导致<strong>进程控制块中的数据被意外修改</strong></font>。</p>
<p>所以需要通过<font color='blue'>将 <code>curenv-&gt;env_tf</code> 复制到当前<strong>栈上一个临时变量</strong> <code>tmp_tf</code>，然后传入 <code>env_pop_tf</code> 函数</font>，从而<font color='red'><strong>避免直接使用进程控制块中的地址</strong></font>。</p>
<p>将 <code>kern/env.c</code> 文件中 <code>env_run</code> 函数的末尾修改为：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span></span><br><span class="line"><span class="addition">+ struct Trapframe tmp_tf = curenv-&gt;env_tf;</span></span><br><span class="line"><span class="addition">+ env_pop_tf(&amp;tmp_tf, curenv-&gt;env_asid);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q：为什么不能将 <code>curenv-&gt;env_tf</code> 复制到 (struct Trapframe *)KSTACKTOP - 1？</p>
<p>因为<code>KSTACKTOP</code> 是内核栈的顶部，直接在此位置存储 <code>Trapframe</code> 结构体稍有不慎可能导致堆栈溢出，从而覆盖其他关键的内核数据，<font color='red'>干扰内核栈的正常使用</font></p>
</blockquote>
<h3 id="fork时相关设置的继承"><a href="#fork时相关设置的继承" class="headerlink" title="fork时相关设置的继承"></a>fork时相关设置的继承</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// lab4-challenge</span></span><br><span class="line">	<span class="comment">// 全部和sigaction有关的都要复制</span></span><br><span class="line">	e-&gt;sig_blocked = curenv-&gt;sig_blocked;</span><br><span class="line">	e-&gt;env_user_sighand_entry = curenv-&gt;env_user_sighand_entry;</span><br><span class="line">	e-&gt;sig_pend_cnt = curenv-&gt;sig_pend_cnt;</span><br><span class="line">	e-&gt;now_sig_time = curenv-&gt;now_sig_time;</span><br><span class="line">	e-&gt;is_handling_SIGKILL = <span class="number">0</span>;</span><br><span class="line">	e-&gt;sig_pend_list = curenv-&gt;sig_pend_list;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">		e-&gt;sig_exist[i] = curenv-&gt;sig_exist[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">		e-&gt;sighand[i].sa_handler = curenv-&gt;sighand[i].sa_handler;</span><br><span class="line">		e-&gt;sighand[i].sa_mask.sig = curenv-&gt;sighand[i].sa_mask.sig;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，<font color='red'>为了防止父进程没有注册信号处理函数</font>，在fork时可以“再加一层保险”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/fork.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// lab4-challenge</span></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;env_user_sighand_entry != (u_int)sighand_entry) &#123;</span><br><span class="line">		try(syscall_set_sighand_entry(<span class="number">0</span>, (u_int)sighand_entry));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页错误处理函数入口的同步设置"><a href="#页错误处理函数入口的同步设置" class="headerlink" title="页错误处理函数入口的同步设置"></a>页错误处理函数入口的同步设置</h3><p>在实际编码中，发现可能会出现页错误情况，报错未注册页错误处理函数。因此，在注册信号时也实现页错误处理函数入口的同步设置</p>
<p>由于 <code>cow_entry</code> 是静态函数，因此需要用一个函数将其包裹以便在其他文件中调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/fork.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">entry_wrapper</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    cow_entry(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他踩过的坑-关键设计"><a href="#其他踩过的坑-关键设计" class="headerlink" title="其他踩过的坑&#x2F;关键设计"></a>其他踩过的坑&#x2F;关键设计</h2><ul>
<li>需要<font color='red'>区分“打断”与“早已到”</font>并妥善设计<ul>
<li><em>问题</em>：在一个信号处理完成之前，也可能会进行一些系统调用，<font color='red'>这些系统调用在返回之前也会扫描信号队列，怎么防止系统转而去执行更早到达的信号（早已到）？</font>但同时，我们也要允许当前处理完成之前，<font color='red'>晚于当前信号到达的信号（打断）能够被先处理</font>。</li>
<li><em>解决思路</em>：<ol>
<li>先在 <code>env.c</code> 里设置一个全局变量 <code>sigsTime</code></li>
<li>每次发送信号的时候让 <code>s-&gt;sig_time=sigsTime</code> ，然后 <code>sigsTime++</code></li>
<li>给 <code>Env</code> 结构体增加成员变量 <code>handlingSig_time</code> ，进程每开始处理一个信号就让 <code>curenv-&gt;handlingSig_time=s-&gt;sig_time</code></li>
<li>在 <code>dosignal</code> 中根据比较 <code>s-&gt;sig_time</code> 和 <code>curenv-&gt;handlingSig_time=s-&gt;sig_time</code> 的大小来判断信号发出的先后</li>
</ol>
</li>
<li><em>不严谨的地方</em>：发送信号的时间不严格等于信号开始被处理的时间，后续可以优化</li>
</ul>
</li>
<li><font color='red'>处理前修改进程掩码，处理后恢复进程原掩码的实现需要小心谨慎</font>，要想清楚到底要恢复成什么样</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://roisyl.github.io/BUAA-SE/BUAA-OS-Lab4-challenge/" data-id="cm7styog5000d0sgpgw2gh52d" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLklEQVR42u3aQY7bQAwEQP//0w6QU4DE3m5Sm8SjmpNhyFqVDr3DIR+PeD1/rleff13J9a/u//t9Ll4YGBgfy3i+Xe2jv3qU99/k93xJxcDAuAEjD9nkUfbX5H8XAwMDIw/TJLLfb/veBz0GBgZGG7hJ2dmy/8H/DQwMjI9itHHZFqV5BH97LY6BgfGBjH1j4Ps+/9X+BgYGxn/JeI7WZtu3L4n/8FsMDIyjGflBWFL0tpE9+yaKXQwMjOMYmwGIthhuh8OK4zYMDIyjGbMWZttubB+uPlbDwMA4lJGPPiS3y1ue7f2/uAYDA+NoRl5A7oveBLYKbgwMjEMZ+dH/bMwiT8UWjIGBcR/GJnBz6qxJmRfSGBgYZzPaH7chOHvc/EU82neJgYHxgYx92TnL+LZ8HbYNMDAwDmK00ZY3I/dvN99uYmBgnM2YdQNnJWjygupZNgwMjNsw2rHUFtOGaT3AioGBcTRjFpezsYkvehQbJAYGxtGMfOS0HU69dv8WFckYGBiHMtq+Qd6YbMfLZttEDAyM+zDyUjM/jNsc4eUbRAwMjDsw2kGHNuU2x2pJFwADA+NsxrNcs6DcN0eLngYGBsZxjFlCXzV+2l7ZFtsYGBgnMTYDXm352h76FxtWDAyMGzD2wZc3O2dbvXrMAgMD48aMdpwiedzNUBoGBgbG7M9c1eDMXxwGBsYdGHkzYBO++dZzeCKIgYFxKGM2nbEJ3M33l/U3MDAwPoPxA3JL+ggqWbqsAAAAAElFTkSuQmCC">分享</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lab/" rel="tag">Lab</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul></div><div class="post-nav"><a class="next" href="/BUAA-SE/BUAA-OS-Lab-General/">BUAA-OS-Lab 经验总结</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="https://unpkg.com/blueimp-md5/js/md5.js"></script><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'Ov23li2QyqRzt8XAlrKY',
  clientSecret: 'd43f2b587c8782b1e92215b56ea07a73762fdfbb',
  repo: 'blog.gitalk',
  owner: 'RoisyL',
  admin: ['RoisyL'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/rabbit.jpg"/></a><p class="author-description">Mind and Hand</p><a class="info-icon" href="https://github.com/RoisyL" title="Welcome to my GitHub" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/BUAA-SE/">BUAA-SE</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Lab/" style="font-size: 15px;">Lab</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab4-challenge/">BUAA-OS-Lab4_challenge sigaction实现</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab-General/">BUAA-OS-Lab 经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab5/">BUAA-OS-Lab5 文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab4/">BUAA-OS-Lab4 系统调用与fork</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab3/">BUAA-OS-Lab3 进程与异常</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab2/">BUAA-OS-Lab2 内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab1/">BUAA OS-Lab1 内核、启动和 PRINTF</a></li><li class="post-list-item"><a class="post-list-link" href="/BUAA-SE/BUAA-OS-Lab0/">BUAA OS-Lab0 Linux基础操作</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Roisy's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/tufu9441"> tufu9441.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>