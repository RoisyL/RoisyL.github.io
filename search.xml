<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-OS-Lab4_challenge sigaction实现</title>
      <link href="/BUAA-SE/BUAA-OS-Lab4-challenge/"/>
      <url>/BUAA-SE/BUAA-OS-Lab4-challenge/</url>
      
        <content type="html"><![CDATA[<h2 id="sigaction简介"><a href="#sigaction简介" class="headerlink" title="sigaction简介"></a><strong>sigaction简介</strong></h2><p><font color="green">当一个信号被发送给一个进程时</font>, 内核会中断进程的正常控制流，转而<strong>执行与该信号相关的用户态处理函数</strong>进行处理</p><p>在<font color="green">执行该处理函数前</font>，会<font color="blue">将该信号所设置的信号屏蔽集加入到进程的信号屏蔽集</font>中，在<font color="green">执行完该用户态处理函数后</font>，又会<font color="blue">将恢复原来的信号屏蔽集</font></p><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a><strong>任务描述</strong></h2><p><code>sigaction</code>结构体用于设置<font color="red"><strong>所需要处理的信号集及其对应的处理函数</strong></font></p><p><code>sigset_t</code>使用<font color="red"><strong>32位</strong></font>表示MOS所需要处理的<font color="red"><strong>[1,32]信号掩码</strong>，对应位为<strong>1表示阻塞</strong>，为0表示未被阻塞</font></p><p><code>sigset_t</code>与<code>sigaction</code>结构体定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigset_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> sig;</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>); <span class="comment">//信号的处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据结构、宏等设计"><a href="#数据结构、宏等设计" class="headerlink" title="数据结构、宏等设计"></a>数据结构、宏等设计</h2><h3 id="信号相关设置"><a href="#信号相关设置" class="headerlink" title="信号相关设置"></a>信号相关设置</h3><p>此处挂起信号队列<font color='blue'>沿用此前MOS中设计的<strong>TAILQ结构</strong>并使用相关函数</font>，实现参考 <code>kern\env.c</code> 中<code>env_sched_list</code> 相关部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/signal.h</span></span><br><span class="line"><span class="comment">// 信号掩码控制宏 __how的取值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_BLOCK (0)<span class="comment">// 添加__set到当前掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_UNBLOCK (1) <span class="comment">// 从当前掩码中移除__set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_SETMASK (2) <span class="comment">// 设置当前掩码为__set</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGNUM编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGINT (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGILL (4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGKILL (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSEGV (11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGCHLD (17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSYS (31)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_MAX (32) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 掩码结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigset_t</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> sig;</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号操作结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*sa_handler)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> &#123;</span></span><br><span class="line">TAILQ_ENTRY(signal) sig_link;</span><br><span class="line"><span class="type">int</span> signum;</span><br><span class="line"><span class="type">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起的信号队列</span></span><br><span class="line">TAILQ_HEAD(Sig_pend_list, signal);</span><br></pre></td></tr></table></figure><h3 id="Env结构体添加成员"><a href="#Env结构体添加成员" class="headerlink" title="Env结构体添加成员"></a>Env结构体添加成员</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line">u_int env_user_sighand_entry;<span class="comment">// 用户态信号处理函数入口</span></span><br><span class="line">u_int now_sig_time;<span class="comment">// 记录当前正在处理的信号的到达时间，重入处理的时候用</span></span><br><span class="line">u_int is_handling_SIGKILL;<span class="comment">// 判定现在正在被处理的是否是SIGKILL信号，若是则为1，反之为0</span></span><br><span class="line">u_int sig_exist[<span class="number">32</span>];<span class="comment">// 每种信号在当前进程的存在性判断，保证每种信号的唯一性</span></span><br><span class="line"><span class="type">sigset_t</span> sig_blocked;       <span class="comment">// 信号掩码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sig_pend_list</span> <span class="title">sig_pend_list</span>;</span><span class="comment">// 挂起信号队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sighand</span>[32];</span>  <span class="comment">// 信号注册数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="错误返回值设置"><a href="#错误返回值设置" class="headerlink" title="错误返回值设置"></a>错误返回值设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/error.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E_SIG 1    <span class="comment">// 实际运用一般都是 return -E_SIG</span></span></span><br></pre></td></tr></table></figure><h3 id="头文件中添加相关函数声明"><a href="#头文件中添加相关函数声明" class="headerlink" title="头文件中添加相关函数声明"></a>头文件中添加相关函数声明</h3><p>由于没有太多技术含量，此处省略，在实现具体函数后到相应头文件中添加即可</p><h2 id="初始化与全局变量设置相关前置操作"><a href="#初始化与全局变量设置相关前置操作" class="headerlink" title="初始化与全局变量设置相关前置操作"></a>初始化与全局变量设置相关前置操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="type">int</span> sigsTime = <span class="number">1</span>;    <span class="comment">// 用于标记信号到达时间，越小则到达时间越早</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> <span class="title">signals</span>[<span class="title">SIG_MAX</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PAGE_SIZE</span>)));</span>    <span class="comment">// 进程信号数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="comment">// 最初都初始化为0</span></span><br><span class="line">e-&gt;sig_blocked.sig = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_user_sighand_entry = <span class="number">0</span>;</span><br><span class="line">e-&gt;sig_pend_cnt = <span class="number">0</span>;</span><br><span class="line">e-&gt;now_sig_time = <span class="number">0</span>;</span><br><span class="line">e-&gt;is_handling_SIGKILL = <span class="number">0</span>;</span><br><span class="line">TAILQ_INIT(&amp;e-&gt;sig_pend_list);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">e-&gt;sig_exist[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">e-&gt;sighand[i].sa_handler = <span class="literal">NULL</span>;</span><br><span class="line">e-&gt;sighand[i].sa_mask.sig = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增相关系统调用"><a href="#新增相关系统调用" class="headerlink" title="新增相关系统调用"></a>新增相关系统调用</h2><h3 id="统一流程"><a href="#统一流程" class="headerlink" title="统一流程"></a>统一流程</h3><p>添加系统调用 <code>syscall_func(u_int envid, ......)</code>：</p><ol><li><p>在 <code>user/include/lib.h</code> 中添加 <code>void syscall_func(u_int envid, ......);</code></p></li><li><p>在 <code>user/lib/syscall_lib.c</code> 中添加</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_func</span><span class="params">(u_int envid, ......)</span> &#123; </span><br><span class="line">......</span><br><span class="line">msyscall(SYS_func, envid, ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>include/syscall.h</code> 中的 <code>enum</code> 的 <code>MAX_SYSNO</code> 前添加 <code>SYS_func,</code></p></li><li><p>在 <code>kern/syscall_all.c</code> 的 <code>void *syscall_table[MAX_SYSNO]</code> 中加上 <code>[SYS_func] = sys_func,</code> （注意与前一步的对应）</p></li><li><p>在 <code>kern/syscall_all.c</code> 的 <code>void *syscall_table[MAX_SYSNO]</code> 之间完成函数<br><code>void sys_func(u_int envid, ......);</code> 的具体实现</p></li></ol><h3 id="新增功能实现所需系统调用的具体实现"><a href="#新增功能实现所需系统调用的具体实现" class="headerlink" title="新增功能实现所需系统调用的具体实现"></a>新增功能实现所需系统调用的具体实现</h3><ul><li><p><code>sys_</code> 具体实现</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="comment">// 信号注册</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, </span></span><br><span class="line"><span class="params">\<span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> *<span class="title">sig</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 只需考虑signum小于或等于32的情况,超出该范围返回-1</span></span><br><span class="line"><span class="keyword">if</span> (signum &lt; <span class="number">1</span> || signum &gt; SIG_MAX) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line">e = curenv;</span><br><span class="line">sig = &amp;e-&gt;sighand[signum - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (oldact) &#123;</span><br><span class="line">*oldact = *sig;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newact) &#123;</span><br><span class="line">*sig = *newact;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进程的信号处理函数入口地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sighand_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">env-&gt;env_user_sighand_entry = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向进程发送信号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sigsTime;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">signal</span> <span class="title">signals</span>[<span class="title">SIG_MAX</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PAGE_SIZE</span>)));</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sendsig</span><span class="params">(u_int envid, <span class="type">int</span> sig)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="comment">// 当envid对应进程不存在，或者sig不符合定义范围时，返回异常码-1</span></span><br><span class="line"><span class="keyword">if</span> ( sig &lt; <span class="number">1</span> || sig &gt; SIG_MAX || envid2env(envid, &amp;e, <span class="number">0</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当进程中已经有同种信号，则不再接收</span></span><br><span class="line"><span class="keyword">if</span> ( e-&gt;sig_exist[sig<span class="number">-1</span>] == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将信号添加进对应进程的信号处理队列</span></span><br><span class="line">signals[sig<span class="number">-1</span>].signum = sig;</span><br><span class="line">signals[sig<span class="number">-1</span>].time = sigsTime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> signal *)(&amp;signals[sig<span class="number">-1</span>]);</span><br><span class="line">e-&gt;sig_exist[sig<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">TAILQ_INSERT_HEAD(&amp;e-&gt;sig_pend_list, (s), sig_link);</span><br><span class="line">sigsTime++;</span><br><span class="line">e-&gt;sig_pend_cnt++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据__how的值更改当前进程的信号屏蔽字</span></span><br><span class="line"><span class="comment">// __set是要应用的新掩码，__oset（如果非NULL）则保存旧的信号屏蔽字</span></span><br><span class="line"><span class="comment">// __how可以是SIG_BLOCK（添加__set到当前掩码）、SIG_UNBLOCK（从当前掩码中移除__set）</span></span><br><span class="line"><span class="comment">//         或SIG_SETMASK（设置当前掩码为__set）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> * __set, <span class="type">sigset_t</span> * __oset)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="type">sigset_t</span> *sigset;</span><br><span class="line">e = curenv;</span><br><span class="line">sigset = &amp;e-&gt;sig_blocked;</span><br><span class="line"><span class="keyword">if</span> (__oset!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">*__oset = *sigset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (__set!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (__how) &#123;</span><br><span class="line"><span class="keyword">case</span> SIG_BLOCK:</span><br><span class="line">sigset-&gt;sig |= __set-&gt;sig;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SIG_UNBLOCK:</span><br><span class="line">sigset-&gt;sig &amp;= ~__set-&gt;sig;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SIG_SETMASK:</span><br><span class="line">sigset-&gt;sig = __set-&gt;sig;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号__signo是否是__set信号集的成员。如果是，返回1；如果不是，返回0。</span></span><br><span class="line"><span class="type">int</span> _sigismember(<span class="type">const</span> <span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)&#123;</span><br><span class="line"><span class="keyword">if</span> (__set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__signo -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> &amp; (__set-&gt;sig &gt;&gt; (__signo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前被阻塞且未处理的信号集，并将其存储在__set中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sigpending</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">uint32_t</span> newSig = __set-&gt;sig;</span><br><span class="line">TAILQ_FOREACH (s, &amp;curenv-&gt;sig_pend_list, sig_link) &#123;</span><br><span class="line"><span class="comment">// 检查掩码</span></span><br><span class="line"><span class="keyword">if</span> ( _sigismember(&amp;curenv-&gt;sig_blocked, s-&gt;signum) ) &#123;</span><br><span class="line">t = s-&gt;signum;</span><br><span class="line">newSig |= (<span class="number">1</span> &lt;&lt; (t<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__set-&gt;sig = newSig;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取进程状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_check_env_status</span><span class="params">(u_int envid)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">e</span>;</span></span><br><span class="line">try(envid2env(envid, &amp;e, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> e-&gt;env_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>部分除 <code>msyscall</code> 还有其他操作的 <code>syscall_</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, </span></span><br><span class="line"><span class="params">\<span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (oldact) &#123;</span><br><span class="line"><span class="built_in">memset</span>(oldact, <span class="number">0</span>, <span class="keyword">sizeof</span>(oldact));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msyscall(SYS_sigaction, signum, newact, oldact);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> * __set, <span class="type">sigset_t</span> * __oset)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (__oset) &#123;</span><br><span class="line"><span class="built_in">memset</span>(__oset, <span class="number">0</span>, <span class="keyword">sizeof</span>(__oset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msyscall(SYS_sigprocmask, __how, __set, __oset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="信号处理流程实现"><a href="#信号处理流程实现" class="headerlink" title="信号处理流程实现"></a>信号处理流程实现</h2><h3 id="信号处理的触发"><a href="#信号处理的触发" class="headerlink" title="信号处理的触发"></a>信号处理的触发</h3><p>在 <code>ret_from_exception</code> 中加入跳转到 <code>do_signal</code> 的代码，<font color='red'>使得每次从用户态到内核态都调用一次信号检查函数</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// kern/genex.S</span><br><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">// 加入跳转到do_signal的代码（每次从用户态到内核态都调用一次）</span><br><span class="line"> move    a0, sp</span><br><span class="line">     addiu   sp, sp, -8</span><br><span class="line">     jal     do_signal</span><br><span class="line">     addiu   sp, sp, 8</span><br></pre></td></tr></table></figure><h3 id="各类信号的发送触发"><a href="#各类信号的发送触发" class="headerlink" title="各类信号的发送触发"></a>各类信号的发送触发</h3><ul><li><p><code>SIGINT</code> 与 <code>SIGKILL</code> 一般在程序中手动触发，不会直接在MOS代码中发送</p></li><li><p><code>SIGILL</code></p><p>  <em>发送契机</em> ：<font color='green'>在进行异常处理前，发现当前异常由<strong>非法指令</strong>引发</font>，向自身发送 <code>SIGILL</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/traps.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_reserved</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(((tf-&gt;cp0_cause &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x1f</span>) == <span class="number">10</span>)&#123;</span><br><span class="line">        sys_sendsig(<span class="number">0</span>, SIGILL);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SIGSEGV</code></p><p>  <em>发送契机</em> ：<font color='green'>当前地址过低不允许访问</font>，则向自身发送 <code>SIGSEGV</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/tlbex.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (va &lt; UTEMP) &#123;</span><br><span class="line"><span class="comment">// panic(&quot;address too low&quot;);</span></span><br><span class="line">sys_sendsig(curenv-&gt;env_id, SIGSEGV);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SIGCHLD</code></p><p>  <em>发送契机</em> ：<font color='green'>子进程退出时，若父进程仍在运行</font>，则子进程向父进程发送 <code>SIGCHLD</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">env_destroy</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="keyword">if</span>( e-&gt;env_parent_id != <span class="number">0</span>)&#123;</span><br><span class="line">sys_sendsig( e-&gt;env_parent_id, SIGCHLD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SIGSYS</code></p><p>  <em>发送契机</em> ：<font color='green'>当前系统调用号不存在时</font>，需要<font color='red'>先<strong>忽视（跳过）此条语句</strong></font>，再向自身发送 <code>SIGSYS</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line"><span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">sys_sendsig(curenv-&gt;env_id, SIGSYS);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="信号的注册与发送"><a href="#信号的注册与发送" class="headerlink" title="信号的注册与发送"></a>信号的注册与发送</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, <span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line"><span class="comment">// 确保设置好信号处理函数入口地址</span></span><br><span class="line"><span class="keyword">if</span> (env-&gt;env_user_sighand_entry != (u_int)sighand_entry) &#123;</span><br><span class="line">try(syscall_set_sighand_entry(<span class="number">0</span>, (u_int)sighand_entry));</span><br><span class="line">try(syscall_set_tlb_mod_entry(<span class="number">0</span>, (u_int)entry_wrapper));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r = syscall_sigaction(signum, newact, oldact);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号发送函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(u_int envid, <span class="type">int</span> sig)</span> &#123;</span><br><span class="line"><span class="comment">// 如果sig为SIGCHLD,SIGILL,SIGSYS,SIGSEGV信号，返回异常码-1</span></span><br><span class="line"><span class="keyword">if</span> (sig == SIGILL || sig == SIGSYS || sig == SIGCHLD || sig == SIGSEGV) &#123;</span><br><span class="line"><span class="comment">// debugf(&quot;Only MOS can send SIGCHLD &amp; SIGILL &amp; SIGSYS &amp; SIGSEGV signal.\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确保设置好信号处理函数入口地址</span></span><br><span class="line"><span class="keyword">if</span> (env-&gt;env_user_sighand_entry != (u_int)sighand_entry) &#123;</span><br><span class="line">try(syscall_set_sighand_entry(<span class="number">0</span>, (u_int)sighand_entry));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r = syscall_sendsig(envid, sig);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号检查"><a href="#信号检查" class="headerlink" title="信号检查"></a>信号检查</h3><ul><li><code>do_signal</code> 实现对当前挂起信号队列的检查，选择合适的信号后<font color='red'>调用 <code>sig_setuptf</code> 跳转到信号处理函数入口并为其传递参数</font></li><li>保存寄存器上下文函数 <code>sig_setuptf</code> 参照 <code>kern\tlbex.c</code> 中 <code>do_tlb_mod</code> 实现，具体参数设计见后续信号处理函数入口</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_signal</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line"><span class="comment">// 在为进程设置sigpri之前也可能会发生一些异常产生异常重入的现象</span></span><br><span class="line"><span class="comment">// 而异常重入的时候不可能产生任何新的信号,没必要处理信号,直接return</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="type">int</span>)tf-&gt;cp0_epc)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有待处理信号，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;curenv-&gt;sig_pend_list))&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>, *s_min = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> signo = <span class="number">10000</span>;    <span class="comment">// 初始化为10000，后续用于判断当前信号优先级是否高于之前选中的信号</span></span><br><span class="line"><span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从进程的队列中取出未被阻塞的signal</span></span><br><span class="line"><span class="comment">// SIGKILL优先级最高</span></span><br><span class="line"><span class="keyword">if</span> (curenv-&gt;sig_exist[SIGKILL<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">,TAILQ_FOREACH (s_min, &amp;curenv-&gt;sig_pend_list, sig_link) &#123;</span><br><span class="line"><span class="keyword">if</span> (s_min-&gt;signum == SIGKILL) &#123;</span><br><span class="line">signo = s_min-&gt;signum;</span><br><span class="line">time = s_min-&gt;time;</span><br><span class="line">curenv-&gt;is_handling_SIGKILL = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(curenv-&gt;is_handling_SIGKILL == <span class="number">0</span>)&#123;</span><br><span class="line">TAILQ_FOREACH (s, &amp;curenv-&gt;sig_pend_list, sig_link) &#123;</span><br><span class="line"><span class="comment">// 如果当前有信号正在处理且此信号比当前信号到达时间早，则break</span></span><br><span class="line"><span class="keyword">if</span> ( s-&gt;time &lt;= curenv-&gt;now_sig_time )&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选取优先级最高的</span></span><br><span class="line"><span class="keyword">if</span> ( s-&gt;signum &lt; signo </span><br><span class="line">&amp;&amp; ( (curenv-&gt;sig_blocked.sig &amp; (<span class="number">1</span>&lt;&lt;(s-&gt;signum<span class="number">-1</span>))) == <span class="number">0</span> ))&#123;</span><br><span class="line">signo = s-&gt;signum;</span><br><span class="line">time = s-&gt;time;</span><br><span class="line">s_min = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若存在未被阻塞的signal, 则修改进程上下文, 转到用户态的信号处理函数</span></span><br><span class="line"><span class="keyword">if</span> (s_min) &#123;</span><br><span class="line">curenv-&gt;now_sig_time = time;</span><br><span class="line">curenv-&gt;sig_exist[signo<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">TAILQ_REMOVE(&amp;curenv-&gt;sig_pend_list, s_min, sig_link);</span><br><span class="line"><span class="comment">// 保存寄存器上下文，给信号处理函数传递参数</span></span><br><span class="line">sig_setuptf(tf, signo);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存寄存器上下文（仿写do_tlb_mod）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_setuptf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf, <span class="type">int</span> signum)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">&#125;</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"><span class="comment">// 将信号处理需要传递的相关参数保存至异常现场栈中</span></span><br><span class="line">tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">tf-&gt;regs[<span class="number">5</span>] = signum;</span><br><span class="line">tf-&gt;regs[<span class="number">6</span>] = (<span class="type">unsigned</span> <span class="type">int</span>)(curenv-&gt;sighand[signum<span class="number">-1</span>].sa_handler);</span><br><span class="line"><span class="type">uint32_t</span> newMask = <span class="number">0</span>;</span><br><span class="line">newMask = curenv-&gt;sighand[signum<span class="number">-1</span>].sa_mask.sig | curenv-&gt;sig_blocked.sig </span><br><span class="line">\ | (<span class="number">1</span> &lt;&lt; (signum - <span class="number">1</span>)) ;</span><br><span class="line">tf-&gt;regs[<span class="number">7</span>] = (<span class="type">uint32_t</span>)newMask;</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">5</span>]);</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">6</span>]);</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">7</span>]);</span><br><span class="line">tf-&gt;cp0_epc = curenv-&gt;env_user_sighand_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号的实际处理"><a href="#信号的实际处理" class="headerlink" title="信号的实际处理"></a>信号的实际处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行信号</span></span><br><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sighand_entry(<span class="keyword">struct</span> Trapframe *tf, <span class="type">int</span> signum, </span><br><span class="line">\<span class="type">void</span> (*sa_handler)(<span class="type">int</span>), <span class="type">uint32_t</span> newMask) &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">// 若设置了处理函数</span></span><br><span class="line"><span class="keyword">if</span> (sa_handler &amp;&amp; signum != SIGKILL ) &#123;</span><br><span class="line"><span class="comment">// 处理前修改进程掩码</span></span><br><span class="line"><span class="type">sigset_t</span> oldSigset=&#123;<span class="number">0</span>&#125;, newSigset=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">newSigset.sig = newMask;</span><br><span class="line">r= syscall_sigprocmask(<span class="number">2</span>, (<span class="type">sigset_t</span> *)&amp;newSigset, (<span class="type">sigset_t</span> *)&amp;oldSigset);</span><br><span class="line">sa_handler(signum);</span><br><span class="line"><span class="comment">// 恢复进程原掩码</span></span><br><span class="line">syscall_sigprocmask(<span class="number">2</span>, (<span class="type">sigset_t</span> *)&amp;oldSigset, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 恢复上下文</span></span><br><span class="line">r = syscall_set_sig_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">user_panic(<span class="string">&quot;sig_entry syscall_set_sig_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">switch</span> (signum) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGINT: <span class="keyword">case</span> SIGILL: <span class="keyword">case</span> SIGKILL: <span class="keyword">case</span> SIGSEGV: </span><br><span class="line"><span class="comment">// 退出用exit</span></span><br><span class="line">            <span class="built_in">exit</span>(); </span><br><span class="line">            user_panic(<span class="string">&quot;sig_entry syscall_env_destroy returned&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            r = syscall_set_sig_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">            user_panic(<span class="string">&quot;sig_entry syscall_set_sig_trapframe returned %d&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信号处理后上下文的信号"><a href="#信号处理后上下文的信号" class="headerlink" title="信号处理后上下文的信号"></a>信号处理后上下文的信号</h3><p>参考同文件中的 <code>sys_set_trapframe</code> 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig_trapframe</span><span class="params">(u_int envid, <span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range((u_long)tf, <span class="keyword">sizeof</span> *tf)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 当前信号处理完毕，故重置 env-&gt;now_sig_time 为 0</span></span><br><span class="line">env-&gt;now_sig_time = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (env == curenv) &#123;</span><br><span class="line">*((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>) = *tf;</span><br><span class="line"><span class="comment">// return `tf-&gt;regs[2]` instead of 0, because return value overrides regs[2] on</span></span><br><span class="line"><span class="comment">// current trapframe.</span></span><br><span class="line"><span class="keyword">return</span> tf-&gt;regs[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">env-&gt;env_tf = *tf;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号集处理函数实现"><a href="#信号集处理函数实现" class="headerlink" title="信号集处理函数实现"></a>信号集<strong>处理函数实现</strong></h2><p>注意如果<font color='green'>传入参数不合法</font>，返回值为 <code>-E_SIG</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"><span class="comment">// 计算两个信号集__left和__right的并集，并将结果存储在__set中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigorset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">const</span> <span class="type">sigset_t</span> *__left, <span class="type">const</span> <span class="type">sigset_t</span> *__right)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __left == <span class="literal">NULL</span> ||  __right == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line">__set-&gt;sig = __left-&gt;sig | __right-&gt;sig;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据__how的值更改当前进程的信号屏蔽字。__set是要应用的新掩码</span></span><br><span class="line"><span class="comment">// __oset（如果非NULL）则保存旧的信号屏蔽字</span></span><br><span class="line"><span class="comment">// __how可以是SIG_BLOCK（添加__set到当前掩码）、SIG_UNBLOCK（从当前掩码中移除__set）</span></span><br><span class="line"><span class="comment">//   或SIG_SETMASK（设置当前掩码为__set）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> * __set, <span class="type">sigset_t</span> * __oset)</span>&#123;</span><br><span class="line">syscall_sigprocmask(__how, __set, __oset);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空参数中的__set掩码，初始化信号集以排除所有信号。这意味着__set将不包含任何信号。(清0)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__set-&gt;sig = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数中的__set掩码填满，使其包含所有已定义的信号。这意味着__set将包括所有信号。(全为1)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line">sigemptyset(__set);</span><br><span class="line">__set-&gt;sig = ~(__set-&gt;sig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向__set信号集中添加一个信号__signo。如果操作成功，__set将包含该信号。(置位为1)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( __signo &lt; <span class="number">1</span> || __signo &gt; SIG_MAX ) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;;</span><br><span class="line">__set-&gt;sig |= (<span class="number">1</span>&lt;&lt;(__signo<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从__set信号集中删除一个信号__signo。如果操作成功，__set将不再包含该信号。(置位为0)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( __signo &lt; <span class="number">1</span> || __signo &gt; SIG_MAX ) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;;</span><br><span class="line">__set-&gt;sig &amp;= ~(<span class="number">1</span>&lt;&lt;(__signo<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号__signo是否是__set信号集的成员。如果是，返回1；如果不是，返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> &amp; (__set-&gt;sig &gt;&gt; (__signo<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号集__set是否为空。如果为空，返回1；如果不为空，返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigisemptyset</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __set-&gt;sig == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个信号集__left和__right的交集，并将结果存储在__set中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigandset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">const</span> <span class="type">sigset_t</span> *__left, <span class="type">const</span> <span class="type">sigset_t</span> *__right)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __left == <span class="literal">NULL</span> ||  __right == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line">__set-&gt;sig = __left-&gt;sig &amp; __right-&gt;sig;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前被阻塞且未处理的信号集，并将其存储在__set中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *__set)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( __set == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_SIG;</span><br><span class="line">&#125;</span><br><span class="line">syscall_sigpending( __set);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他修改（踩过的坑）"><a href="#其他修改（踩过的坑）" class="headerlink" title="其他修改（踩过的坑）"></a>其他修改（踩过的坑）</h2><h3 id="寄存器Trapframe保存与传递设置"><a href="#寄存器Trapframe保存与传递设置" class="headerlink" title="寄存器Trapframe保存与传递设置"></a>寄存器Trapframe保存与传递设置</h3><p>当 <code>env_pop_tf</code> 函数被调用时，它会将 <code>curenv-&gt;env_tf</code>（即当前进程的上下文）加载到处理器寄存器中，并且将 <code>curenv-&gt;env_tf</code> 的地址赋值给堆栈指针 <code>sp</code>。进入 <code>do_signal</code> 函数时，堆栈指针 <code>sp</code> 指向 <code>curenv-&gt;env_tf</code> 的位置。</p><p>假设 <code>do_signal</code> 函数会在其执行过程中使用堆栈保存临时数据和函数调用信息，则<font color='red'>这些数据会<strong>覆盖</strong> <code>curenv-&gt;env_tf</code> 的内容，导致<strong>进程控制块中的数据被意外修改</strong></font>。</p><p>所以需要通过<font color='blue'>将 <code>curenv-&gt;env_tf</code> 复制到当前<strong>栈上一个临时变量</strong> <code>tmp_tf</code>，然后传入 <code>env_pop_tf</code> 函数</font>，从而<font color='red'><strong>避免直接使用进程控制块中的地址</strong></font>。</p><p>将 <code>kern/env.c</code> 文件中 <code>env_run</code> 函数的末尾修改为：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span></span><br><span class="line"><span class="addition">+ struct Trapframe tmp_tf = curenv-&gt;env_tf;</span></span><br><span class="line"><span class="addition">+ env_pop_tf(&amp;tmp_tf, curenv-&gt;env_asid);</span></span><br></pre></td></tr></table></figure><blockquote><p>Q：为什么不能将 <code>curenv-&gt;env_tf</code> 复制到 (struct Trapframe *)KSTACKTOP - 1？</p><p>因为<code>KSTACKTOP</code> 是内核栈的顶部，直接在此位置存储 <code>Trapframe</code> 结构体稍有不慎可能导致堆栈溢出，从而覆盖其他关键的内核数据，<font color='red'>干扰内核栈的正常使用</font></p></blockquote><h3 id="fork时相关设置的继承"><a href="#fork时相关设置的继承" class="headerlink" title="fork时相关设置的继承"></a>fork时相关设置的继承</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="comment">// 全部和sigaction有关的都要复制</span></span><br><span class="line">e-&gt;sig_blocked = curenv-&gt;sig_blocked;</span><br><span class="line">e-&gt;env_user_sighand_entry = curenv-&gt;env_user_sighand_entry;</span><br><span class="line">e-&gt;sig_pend_cnt = curenv-&gt;sig_pend_cnt;</span><br><span class="line">e-&gt;now_sig_time = curenv-&gt;now_sig_time;</span><br><span class="line">e-&gt;is_handling_SIGKILL = <span class="number">0</span>;</span><br><span class="line">e-&gt;sig_pend_list = curenv-&gt;sig_pend_list;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">e-&gt;sig_exist[i] = curenv-&gt;sig_exist[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">e-&gt;sighand[i].sa_handler = curenv-&gt;sighand[i].sa_handler;</span><br><span class="line">e-&gt;sighand[i].sa_mask.sig = curenv-&gt;sighand[i].sa_mask.sig;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，<font color='red'>为了防止父进程没有注册信号处理函数</font>，在fork时可以“再加一层保险”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/fork.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">// lab4-challenge</span></span><br><span class="line"><span class="keyword">if</span> (env-&gt;env_user_sighand_entry != (u_int)sighand_entry) &#123;</span><br><span class="line">try(syscall_set_sighand_entry(<span class="number">0</span>, (u_int)sighand_entry));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页错误处理函数入口的同步设置"><a href="#页错误处理函数入口的同步设置" class="headerlink" title="页错误处理函数入口的同步设置"></a>页错误处理函数入口的同步设置</h3><p>在实际编码中，发现可能会出现页错误情况，报错未注册页错误处理函数。因此，在注册信号时也实现页错误处理函数入口的同步设置</p><p>由于 <code>cow_entry</code> 是静态函数，因此需要用一个函数将其包裹以便在其他文件中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/fork.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">entry_wrapper</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    cow_entry(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他踩过的坑-关键设计"><a href="#其他踩过的坑-关键设计" class="headerlink" title="其他踩过的坑&#x2F;关键设计"></a>其他踩过的坑&#x2F;关键设计</h2><ul><li>需要<font color='red'>区分“打断”与“早已到”</font>并妥善设计<ul><li><em>问题</em>：在一个信号处理完成之前，也可能会进行一些系统调用，<font color='red'>这些系统调用在返回之前也会扫描信号队列，怎么防止系统转而去执行更早到达的信号（早已到）？</font>但同时，我们也要允许当前处理完成之前，<font color='red'>晚于当前信号到达的信号（打断）能够被先处理</font>。</li><li><em>解决思路</em>：<ol><li>先在 <code>env.c</code> 里设置一个全局变量 <code>sigsTime</code></li><li>每次发送信号的时候让 <code>s-&gt;sig_time=sigsTime</code> ，然后 <code>sigsTime++</code></li><li>给 <code>Env</code> 结构体增加成员变量 <code>handlingSig_time</code> ，进程每开始处理一个信号就让 <code>curenv-&gt;handlingSig_time=s-&gt;sig_time</code></li><li>在 <code>dosignal</code> 中根据比较 <code>s-&gt;sig_time</code> 和 <code>curenv-&gt;handlingSig_time=s-&gt;sig_time</code> 的大小来判断信号发出的先后</li></ol></li><li><em>不严谨的地方</em>：发送信号的时间不严格等于信号开始被处理的时间，后续可以优化</li></ul></li><li><font color='red'>处理前修改进程掩码，处理后恢复进程原掩码的实现需要小心谨慎</font>，要想清楚到底要恢复成什么样</li></ul>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab 经验总结</title>
      <link href="/BUAA-SE/BUAA-OS-Lab-General/"/>
      <url>/BUAA-SE/BUAA-OS-Lab-General/</url>
      
        <content type="html"><![CDATA[<h1 id="官方提醒"><a href="#官方提醒" class="headerlink" title="官方提醒"></a>官方提醒</h1><ul><li>在之后的 Lab 中，运行 MOS 时容易出现的 <font color="green"><strong>too low</strong> </font>等错误信息就是访问了一个过低的地址导致的。此时应该检查代码中<strong>是否存在访问非法内存（如空指针、野指针）的操作，或者忘记将物理地址转化为 kseg0 内核虚拟地址的问题</strong>。</li></ul><h1 id="实验代码阅读与把握"><a href="#实验代码阅读与把握" class="headerlink" title="实验代码阅读与把握"></a>实验代码阅读与把握</h1><ul><li>整体结构把握<ul><li>完整的函数调用关系可以<font color="blue">查看指导书每个Lab后面的调用顺序图（<strong>利用好指导书</strong>）</font></li><li><font color="blue">把握好顶层架构</font><br>为什么这样划分文件结构？每部分文件的作用是什么？它们怎么协同？弄明白了这些问题，才能更顺利地编码</li><li><font color="blue">用好外部变量</font><br>很多时候<font color="green">要用的量和想实现的功能</font>在相应的文件中都有宏定义或者函数定义。所以先阅读文件，找不到再自己写</li></ul></li><li>具体参数意义理解<ul><li><font color="blue">通过检索的方式在指导书、讲解 PPT 等多处资源中广泛找思路</font><ul><li>比如<code>vprintfmt</code>参数列表中的<code>data</code>是什么？<br>指导书中没有说明，但讲解 PPT 中讲的很清楚。不要纠结与单一资料，学会广泛检索。</li></ul></li><li><font color="blue"><strong>通过阅读并理解更大范围（比如完整函数、上层调用函数）代码段，明白本质，进而把握单个参数意义</strong></font><ul><li>比如<code>vprintfmt</code>参数列表中<code>ap</code>这一可变参数指的是哪些参数？<br><code>vprintfmt</code>函数实现的是格式化输出的主体逻辑，被<code>printk</code>调用，参数列表中的 ap 参数也是从上层函数中得来。结合<code>printk</code>的用法，比如<code>printk(&quot;%d%c%ld&quot;, a, b, c)</code>，很容易明白可变参数就是需要输出的一系列变量，而<code>fmt</code>就是引号中的字符串。</li></ul></li></ul></li></ul><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><ul><li>“由俭入奢易，由奢入俭难“，某种程度上也适用于代码编写。<font color="red">用最<strong>简单直接精炼</strong>的代码实现，不要为求安心无脑加一些<strong>似是似非</strong>的代码</font>，容易导致一些意想不到的错误而且难找原因。一定要<font color="green"><strong>百分百确定有漏洞</strong></font>才<font color="blue"><strong>恰当地打补丁</strong></font>。</li><li><strong>不是只填空就可以了</strong>，注意初始代码的改动。<font color="red">（<strong>已经定义好的参数的初始化</strong>）代码本身的行为一定要明确！</font> <font color="blue">比如处理好各变量初值（0、NULL），空指针使用</font>。不要过渡依赖编译器</li><li><font color="blue"><strong>解引用指针之前必须判断是否为空&#x2F;试错（见后”常用函数“）</strong>！！！</font>野指针会导致死循环或超时无法结束<ul><li><font color="color">注意不同函数的错误值不一样</font>，<font color="blue"><strong>不要混用</strong></font>！！</li></ul></li><li><font color="green">“仿照xxx部分进行实现”，<strong>有一些部分不确定要不要保留</strong></font>就<font color="blue"><strong>先保留</strong></font>！！（很有可能涉及到一些隐性机制的实现）</li><li><font color="green">“当出现错误时返回相应错误值”</font>常用操作是<font color="blue">用<code>r</code>记录返回值再判断**<code>if(r&gt;0)</code>**</font><ul><li>是判断是否<font color="red">&gt;0</font>！！错误值一般都是负值，<font color="red"><strong>正常值不一定是0也可能是正数</strong></font>！！</li></ul></li><li><font color="green">用 gitlab IDE 编辑提交之后，切回跳板机运行前</font>记得<code>git pull</code>！！</li><li>写<font color="green"><strong>循环</strong></font>时一定注意<ul><li><font color="red"><strong>i++</strong></li><li>数据更新（比如每次开始前<strong>读入下一部分数据</strong>）</font></li></ul></li><li>注意<strong>运算符优先级</strong><ul><li><strong>移位运算符的优先级低于加号</strong>，需要加括号</li><li><code>*</code> 优先级低于 <code>.</code> <code>→</code> ，故不需要加括号</li></ul></li></ul><h1 id="调试-debug"><a href="#调试-debug" class="headerlink" title="调试&#x2F;debug"></a>调试&#x2F;debug</h1><ul><li>debug 时优先检查<font color="red"><strong>条件判断</strong></font>是否出错！<ul><li>less than，应该是<code>-lt</code> 不是 <code>-le</code> 🥲</li></ul></li><li>先本地<strong>开优化</strong>编译运行！<strong>根据报错或者运行异常去找原因</strong>，实在不行加<font color="blue"><strong>printf</strong></font></li></ul><h2 id="make-的使用"><a href="#make-的使用" class="headerlink" title="make 的使用"></a>make 的使用</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li><code>make</code> 编译完整内核<ul><li>需要在 init&#x2F;init.c 的 mips_init 里添加自己的测试代码</li></ul></li><li><code>make test lab=&lt;x&gt;_&lt;y&gt;</code>编译指定测试点， lab<x> 的第 y 个测试用例<br>eg make test lab&#x3D;1_2</li></ul><h3 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h3><ul><li><code>make run</code> 运行</li><li><code>make dbg</code> 使用 QEMU 模拟器以调试模式运行内核，并进入 GDB 调试界面。</li><li><code>make objdump</code> 将项目中的目标文件反汇编</li><li><code>Ctrl+A+X</code> 退出 QEMU</li></ul><h1 id="实验代码结构"><a href="#实验代码结构" class="headerlink" title="实验代码结构"></a>实验代码结构</h1><ul><li><p>kern里的.c文件和include里面的.h文件很多是一一对应的，分别为某部分功能的实现以及相关函数、宏定义</p></li><li><p>include目录——存放系统头文件和一些常用函数定义</p><ul><li><p>mmu.h——存储内存布局、<strong>与地址转换、虚拟地址管理</strong>相关的宏</p><ul><li>有一张内存布局图，在填写 linker script 的时候需要<strong>根据这个图设置相应节的加载地址</strong></li><li><code>PDX(va)</code> ：页目录偏移量（查找遍历页表时常用）</li><li><code>PTX(va)</code> ：页表偏移量（查找遍历页表时常用）</li><li><code>PTE_ADDR(pte)</code> ：获取页表项中的物理地址（读取 pte 时常用）</li><li><code>PADDR(kva)</code> ：kseg0 处虚地址 物理地址</li><li><code>KADDR(pa)</code> ：物理地址 kseg0 处虚地址（读取 pte 后可进行转换）</li></ul></li><li><p>pmap.h ——存储与<strong>地址</strong>相关的宏</p><ul><li><code>va2pa(Pde *pgdir, u_long va)</code> ：查页表，虚地址 物理地址（测试时常用</li><li><code>pa2page(u_long pa)</code> ：物理地址 页控制块（读取 pte 后可进行转换）</li><li><code>page2pa(struct Page *pp)</code> ：页控制块 物理地址（填充 pte 时常用）</li></ul></li><li><p>print.h</p><ul><li>声明了<em>vprintfmt</em>函数，解释了相关参数</li></ul></li><li><p>string.h——定义了一些常用的字符串函数，忘记了具体参数含义可以来这里找</p></li><li><p>printk.h——定义了<strong>内核崩溃宏</strong></p></li><li><p>elf.h</p><ul><li>ELF_FOREACH_PHDR_OFF——<em>for循环迭代遍历所有段头</em></li></ul></li><li><p>type.h——定义和align有关的宏</p><ul><li><code>ROUNDDOWN(a, n)</code> 返回 ⌊$\frac{a}{n}$⌋n（将 a 按 n 向下对齐）,要求 n 必须是 2 的非负整数次幂</li><li><code>ROUND(a, n)</code>  返回 ⌈$\frac{a}{n}$⌉n（将 a 按 n 向上对齐）,要求 n 必须是 2 的非负整数次幂</li></ul></li><li><p>queue.h——<strong>链表、双向队列宏</strong>的定义</p><p>  太多了…具体功能见文件注释</p></li><li><p>trap.h——定义Trapframe结构体</p></li><li><p>env.h——和进程调度有关的结构体定义</p></li><li><p>stackframe.h——定义宏 SAVE_ALL</p><ul><li><code>SAVE_ALL</code>——将当前的 CPU 现场（上下文）保存到内核的异常栈中</li></ul></li><li><p>kclock.h——定义RESET_KCLOCK 宏，完成了对 CP0 中 Timer 的配置</p></li><li><p>syscall.h——定义系统调用号</p></li></ul></li><li><p>include.mk</p></li><li><p>init目录——初始化内核相关代码</p><ul><li><p>start.S</p><ul><li><p>_start 函数</p><p>  是 CPU 控制权被转交给内核后执行的<strong>第一个函数</strong>，主要工作是初始化 CPU 和栈指针，然后跳转至 MOS 的初始化函数（ mips_init ）</p><p>  内核栈空间的地址可以在 include&#x2F;mmu.h 中看到，注意栈的增长方向</p></li></ul></li><li><p>init.c</p><ul><li><p>mips_init 函数</p><p>  内核中<strong>各模块的初始化函数</strong>都会在这里被调用</p></li></ul></li></ul></li><li><p>kern目录——存放内核的主体代码</p><ul><li><p>machine.c——往 QEMU 的控制台输出、读入字符，重置系统</p><p>  原理为读写某一个特殊的内存地址</p></li><li><p>printk.c——实现了 printk</p><p>  实际上是把输出字符的函数，接受的输出参数给传递给了 vprintfmt 这个函数</p></li><li><p>console.c——实现printcharc（向某内存地址写入）</p></li><li><p>pmap.c——实现内存管理</p><ul><li>page_init()  初始化 pages 数组中的 Page 结构体以及空闲链表</li><li>mips_detect_memory()  探测硬件可用内存，并对一些和内存管理相关的变量进行初始化</li><li>mips_vm_init 建立内存管理机制</li><li>alloc（） 注意！只在建立页式内存管理机制之前使用</li></ul></li><li><p>env.c——实现进程调度</p></li><li><p>traps.c——定义异常向量组，用于定位中断处理程序</p></li><li><p>genex.S —— 异常处理函数的声明，异常处理流程实现</p></li><li><p>env_asm.S</p><ul><li>env_pop_tf ——用于设置 ASID 和重置时钟，以及最后从异常处理中返回</li></ul></li><li><p>sched.c——实现时间片调度</p></li><li><p>syscall_all.c——系统调用相关函数实现</p><ul><li>do_syscall——内核部分的系统调用机制实现</li></ul></li><li><p>tlbex.c——写时复制相关函数的实现</p></li></ul></li><li><p>kernel.lds</p></li><li><p>lib目录——存放一些常用库函数的实现</p><ul><li>print.c——实现了 <strong>vprintfmt 函数(实现了格式化输出的主体逻辑)、打印字符、字符串和数字的函数</strong></li><li>string——实现了一些常用的字符串函数</li><li>elfloader.c——解析 ELF 文件的相关函数和宏</li></ul></li><li><p>Makefile</p></li><li><p>mk目录</p></li><li><p>tests目录——存放公开的测试用例</p></li><li><p>tools目录——构建时辅助工具的代码</p><ul><li>readelf目录<ul><li><p>elf.h ——存放解析ELF文件要用的三个关键数据结构</p><ul><li>包括三个结构体，第一个对应ELF 的文件头，第二个对应节（section）头表，第三个对应段（segment）头表</li></ul></li><li><p>readelf.c ——用于解析ELF文件</p><ul><li>is_elf_format函数——判断输入是否为ELF文件</li><li>readelf 函数——输出 ELF 文件中所有节头中的地址信息</li></ul></li></ul></li><li>fsformat.c——创建符合我们定义的文件系统镜像的工具</li></ul></li><li><p>user目录</p><ul><li>lib目录<ul><li>debug.c——实现debugf函数（处理8号异常）</li><li>syscall_lib.c ——实现syscall_* 函数</li><li>fork.c<ul><li>fork 函数——fork机制实现的核心</li><li>cow_entry 函数——写时复制处理的函数</li><li>duppage 函数——父进程对子进程页面空间进行映射以及相关标志的函数</li></ul></li><li>entry.S——用户进程的入口</li><li>libos.c——用户进程入口的 C 语言部分</li><li>file.c、fd.c、fsipc.c —— 存放文件系统用户库<ul><li>fsipc.c ——实现与文件系统服务进程的交互</li><li>file.c ——实现文件系统的用户接口</li><li>fd.c ——实现文件描述符，允许用户程序使用统一接口操作文件</li></ul></li></ul></li><li>include目录<ul><li>lib.h——系统调用相关宏定义</li><li>syscall.h——定义系统调用号</li></ul></li></ul></li><li><p>fs目录——文件系统服务程序</p><ul><li>fs.c ——实现文件系统的基本功能函数</li><li>ide.c ——通过系统调用与磁盘镜像进行交互</li><li>serv.c 中——文件系统服务进程主干函数，通过 IPC 通信与用户进程 user&#x2F;lib&#x2F;fsipc.c 内的通信函数进行交互</li></ul></li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><p>错误处理相关</p><p>  用try最稳妥</p><ul><li><code>panic_on</code> 直接崩溃</li><li><code>try / if(某操作返回值==错误值)</code> 抛出去给上层函数处理</li><li><code>user_panic</code> 用户态进程崩溃<ul><li>user_panic(“syscall_set_trapframe returned %d”, r);</li></ul></li></ul></li><li><p>清空内存 <code>memset</code>  实现于lib&#x2F;string.c</p></li><li><p><code>ROUND(a, n)</code>  返回 ⌈$\frac{a}{n}$⌉n（将 a 按 n 向上对齐）,要求 n 必须是 2 的非负整数次幂</p></li></ul><h1 id="一些-Q-A"><a href="#一些-Q-A" class="headerlink" title="一些 Q &amp; A"></a>一些 Q &amp; A</h1><blockquote><p>在编写操作系统的c代码时，变量分别存放在哪部分物理内存？page_alloc() 申请的物理页面用来存什么？</p></blockquote><p>代码段、全局变量和静态变量在编译阶段被确定，链接时被链入0x8002 0000向上这部分物理内存</p><p>临时变量在内核栈区，被存放在0x8040 0000向下<em>KSTKSIZE</em>部分内存。</p><p>申请物理页面的用途：lab3用于给新进程申请页目录、给内核进程加载外部二进制elf文件并执行；lab4用于为用户进程申请用户栈、duppage()时为COW复制的页表申请物理空间；lab5在进程内存放文件内容、lab6用于给用户进程加载外部二进制elf文件来执行命令。申请的页面存放在0x8040 0000向上这部分物理内存</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab5 文件系统</title>
      <link href="/BUAA-SE/BUAA-OS-Lab5/"/>
      <url>/BUAA-SE/BUAA-OS-Lab5/</url>
      
        <content type="html"><![CDATA[<h1 id="指导书梳理"><a href="#指导书梳理" class="headerlink" title="指导书梳理"></a>指导书梳理</h1><h2 id="MOS文件系统设计"><a href="#MOS文件系统设计" class="headerlink" title="MOS文件系统设计"></a>MOS文件系统设计</h2><p>文件系统将外部设备中的资源抽象为文件，从而可以统一管理外部设备，包括文件设备（file，狭义的“文件”）、控制台（console）和管道（pipe）</p><h3 id="构成部分"><a href="#构成部分" class="headerlink" title="构成部分"></a>构成部分</h3><ol><li>外部存储设备驱动<ul><li>该驱动程序将通过系统调用的方式陷入内核，对磁盘镜像进行读写操作</li></ul></li><li>文件系统结构<ul><li>MOS 中的文件系统服务进程实际上也是一个运行在用户态下的进程</li></ul></li><li>文件系统的用户接口</li></ol><h3 id="MOS-微内核设计"><a href="#MOS-微内核设计" class="headerlink" title="MOS 微内核设计"></a>MOS 微内核设计</h3><ul><li>将文件系统移出内核，使用用户态的文件系统服务程序以及一系列用户库来实现<ul><li>用户进程通过进程间通信(IPC) 来请求文件系统的相关服务</li></ul></li><li>将一些内核数据暴露到用户空间，使得进程不需要切换到内核态就能访问</li><li>将传统操作系统的设备驱动移出内核，内核仅提供读写设备物理地址的系统调用</li></ul><h2 id="IDE-磁盘驱动"><a href="#IDE-磁盘驱动" class="headerlink" title="IDE 磁盘驱动"></a>IDE 磁盘驱动</h2><p>本次要实现的硬盘驱动程序与已经实现的串口驱动，都采用 MMIO （内存映射IO）技术编写驱动，完全运行在用户空间</p><h3 id="内存映射-I-O-MMIO"><a href="#内存映射-I-O-MMIO" class="headerlink" title="内存映射 I&#x2F;O (MMIO)"></a>内存映射 I&#x2F;O (MMIO)</h3><ul><li><em><strong>I&#x2F;O 端口</strong></em>实质上是外设寄存器<ul><li>通常包括控制寄存器、状态寄存器和数据寄存器，这些寄存器被映射到指定的物理地址空间</li></ul></li><li>在 MIPS 的内核地址空间中，对 kseg1 段地址的读写不经过 MMU 映射，且不使用高速缓存。且在模拟器上运行操作系统，I&#x2F;O 设备物理地址完全固定，因此可以通过简单地读写某些固定的内核虚拟地址来实现驱动程序的功能</li><li>在编写设备驱动的时候，<strong>将物理地址转换为 kseg1 段的内核虚拟地址</strong>，也就是给物理地址加上 kseg1 的偏移值(<strong>0xA0000000</strong>)</li></ul><h3 id="IDE-磁盘"><a href="#IDE-磁盘" class="headerlink" title="IDE 磁盘"></a>IDE 磁盘</h3><ul><li><p>MALTA 平台上的 PIIX4 磁盘控制器基地址为 <strong>0x180001F0</strong>，在 MOS 中，我们可以挂载两块 IDE 磁盘，但实际上只用编号为 0 的一块磁盘</p></li><li><p>由于 CHS 模式不方便寻址，采用逻辑块寻址（LBA）进行扇区寻址。在 LBA 模式下，IDE 设备将磁盘看作一个线性的字节序列，每个扇区都有一个唯一的编号，只需要设置目标扇区编号，就可以完成磁盘的寻址</p><p>  <img src="https://s2.loli.net/2024/08/29/FCWHZtNoX56AwVU.png" alt="Untitled"></p><p>  <img src="https://s2.loli.net/2024/08/29/2GzXWtsdMja5KnO.png" alt="Untitled"></p></li><li><p>MOS中扇区编号有 28 位</p></li></ul><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a>驱动程序编写</h3><ul><li><p>磁盘操作中所有的地址操作都需要将物理地址转换成虚拟地址。此处设备基地址对应的 kseg1 的内核虚拟地址是 <strong>0xB80001F0</strong></p></li><li><p>由于 IDE 外设一般不能立即完成数据操作，需要 CPU 检查 IDE 状态并等待操作完成</p></li><li><p>读写注意</p><ul><li>本实验中使用的 IDE 设备无法一次性写入操作扇区号，因此需要<strong>单独设置扇区号的各位</strong><ul><li>特别地，在设置操作扇区号的 [27:24] 位时，还需要同时设置扇区寻址模式和磁盘编号，因此需要通过位运算将各值组合，并一齐写入对应地址</li></ul></li><li>由于本实验中使用的 IDE 设备每次仅能读取或写入 4 字节，因此需要通过一个循环完成整个扇区的读取或写入，即连续向相同的地址读取或写入 4 字节</li></ul><p>  <img src="https://s2.loli.net/2024/08/29/3Fnps8xkRTlOKV2.png" alt="Untitled"></p></li></ul><h2 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h2><h3 id="磁盘文件系统布局"><a href="#磁盘文件系统布局" class="headerlink" title="磁盘文件系统布局"></a>磁盘文件系统布局</h3><p><img src="https://s2.loli.net/2024/08/29/eHTDrY95PhVtmGM.png" alt="Untitled"></p><ul><li><em><strong>磁盘块</strong></em>是一个虚拟概念，是操作系统与磁盘交互的最小单位；操作系统将相邻的扇区组合在一起，形成磁盘块进行整体操作</li><li>MOS 操作系统把磁盘最开始的一个磁盘块（4096 字节）当作引导扇区和分区表使用，接下来的一个磁盘块作为超级块（Super Block）</li><li>使用位图 (Bitmap) 法来管理空闲的磁盘资源，用一个二进制位 bit 标识磁盘中的一个磁盘块的使用情况（<strong>1 表示空闲，0 表示占用</strong>）</li></ul><h3 id="文件系统详细结构"><a href="#文件系统详细结构" class="headerlink" title="文件系统详细结构"></a>文件系统详细结构</h3><ul><li><p><code>File</code>结构体</p><ul><li><p><code>f_direct[NDIRECT]</code> 文件的直接指针</p><p>  每个文件控制块设有 10 个直接指针，用来记录文件的数据块在磁盘上的位置。每个磁盘块的大小为 4KB，能够表示最大 40KB 的文件，大于 40KB 时需要用到间接指针</p></li><li><p><code>f_indirect</code> 指向一个间接磁盘块，存储指向文件内容的磁盘块的指针。为简化计算，不使用间接磁盘块的前十个指针</p></li><li><p><code>f_pad</code> 让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节</p></li><li><p>对于普通的文件，其指向的磁盘块存储着文件内容，而对于目录文件来说，其指向的磁盘块存储着该目录下各个文件对应的文件控制块</p><p>  <img src="https://s2.loli.net/2024/08/29/tUPQEVuXAcHB2GK.png" alt="Untitled"></p></li></ul></li><li><p>通过 fsformat（由 tools&#x2F;fsformat.c 编译而成）程序来创建一个磁盘镜像文件 target&#x2F;fs.img，模拟与真实的磁盘文件设备的交互</p></li></ul><h3 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h3><p>MOS文件系统服务是一个用户进程，一个进程可以拥有 4GB 的虚拟内存空间，将 DISKMAP 到DISKMAP+DISKMAX 这一段虚存地址空间 (0x10000000-0x4FFFFFFF) 作为缓冲区，当磁盘读入内存时，用来映射相关的页</p><p><img src="https://s2.loli.net/2024/08/29/yEIhT579czm2iSf.png" alt="6.png"></p><h2 id="文件系统的用户接口"><a href="#文件系统的用户接口" class="headerlink" title="文件系统的用户接口"></a>文件系统的用户接口</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul><li>文件描述符存储文件的基本信息和用户进程中关于文件的状态，也起到描述用户对于文件操作的作用</li><li>当用户进程向文件系统发送打开文件的请求时，文件系统进程会将这些基本信息记录在内存中，然后由操作系统<strong>将用户进程请求的地址映射到同一个存储了文件描述符的物理页上</strong>（此部分代码位于 serv.c 的 serve_open 函数内），因此<strong>一个文件描述符至少需要独占一页的空间</strong>。当用户进程获取基本信息后，再次向文件系统发送请求将文件内容映射到指定内存空间中</li></ul><h3 id="文件系统服务"><a href="#文件系统服务" class="headerlink" title="文件系统服务"></a>文件系统服务</h3><p><img src="https://s2.loli.net/2024/08/29/PYHaVNdU3rtu48x.png" alt="7.png"></p><h1 id="时纪"><a href="#时纪" class="headerlink" title="时纪"></a>时纪</h1><p>E 5.1</p><ul><li><p>常用函数</p><ul><li><code>is_illegal_va_range</code> 判断虚拟地址合法性</li></ul></li><li><p>注意开闭区间</p><p>  写入的地址区间是 <code>[pa, pa + len)</code>，其中最高的地址是 <code>pa + len - 1</code>。应当判断 <code>pa + len - 1 &lt; PA_BASE + PA_LEN</code>，也就是 <code>pa + len &lt;= PA_BASE + PA_LEN</code></p></li></ul><p>E 5.4 </p><p><strong>“当出现错误时返回相应错误值”<strong>常用操作用<code>r</code>记录返回值再判断</strong><code>if(r&gt;0)</code></strong></p><ul><li>是判断是否**&gt;0**！！错误值一般都是负值，<strong>正常值不一定是0也可能是正数</strong>！！</li></ul><h1 id="上机准备"><a href="#上机准备" class="headerlink" title="上机准备"></a>上机准备</h1><h2 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h2><p><img src="https://s2.loli.net/2024/08/29/xsNcLE7wt9ORCqu.png" alt="Untitled"></p><h3 id="文件在各个层次的抽象"><a href="#文件在各个层次的抽象" class="headerlink" title="文件在各个层次的抽象"></a>文件在各个层次的抽象</h3><ul><li><p>用户进程中（非服务进程）—— user文件夹下文件</p><ul><li><p><strong>文件的抽象形式是文件描述符Fd</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    u_int fd_dev_id;</span><br><span class="line">    u_int fd_offset; <span class="comment">// 定位指针</span></span><br><span class="line">    u_int fd_omode; <span class="comment">// 打开形式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> &#123;</span><br><span class="line">    .dev_id =   <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    .dev_name = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .dev_read = file_read,</span><br><span class="line">    .dev_write =    file_write,</span><br><span class="line">    .dev_close =    file_close,</span><br><span class="line">    .dev_stat = file_stat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>user的文件描述符Fd来源于serv通过ipc的页面共享ffd</li><li>可能会调到对应的Fd中的dev_id的dev的对应函数，在文件系统中也就是file_close、file_write等</li><li>内存空间中有专门的地址存放文件描述符，也就是FDTABLE，这里可以看成一个数组，每个Fd占一个Page大小，可以直接用fdnum作为下标获得</li></ul></li><li><p><code>fsipc_xxx</code>实现与服务进程的交互</p><p>  其实就是<strong>找到相应的文件描述符Fd（毕竟这时还在用户进程中），然后构造相应类别的请求req</strong>，再通过ipc将该req发送给服务进程（其实就是把req的页面共享给服务进程），最后通过ipc_recv从服务进程中<strong>收到相应的结果</strong></p></li></ul></li><li><p>服务进程 —— serve相关</p><ul><li><p><strong>文件在服务进程抽象存在形式是Open</strong>，其中有一个<strong>Filefd的指针</strong>，也存储了文件的相关信息。而在fs&#x2F;serv.c中，有一个Open的数组opentable</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// 对应的文件控制块</span></span><br><span class="line">    u_int o_fileid;     <span class="comment">// 文件id（可以看做当前打开的文件，每个都有个id）</span></span><br><span class="line">    <span class="type">int</span> o_mode;     <span class="comment">// 打开形式</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span>    <span class="comment">// Filefd</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span> <span class="comment">// 文件描述符</span></span><br><span class="line">    u_int f_fileid; <span class="comment">// 文件id（同上）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">// 文件控制块</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    u_int fd_dev_id;</span><br><span class="line">    u_int fd_offset; <span class="comment">// 定位指针</span></span><br><span class="line">    u_int fd_omode; <span class="comment">// 打开形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>serve_xxx</code> 调用底层函数处理用户进程请求</p><p>  首先是从请求req中提取有关信息，如fileid等，<strong>从而找到对应的Open</strong>（如果是serve_open则是分配Open），就相当于找到了服务进程中对应的文件，这时候就可以调用底层的函数（fs&#x2F;fs.c）中来把相应的Block从磁盘读入服务进程的内存空间中或对相应的Block进行操作</p></li></ul></li><li><p>内核（底层实现）—— fs、kern相关</p><ul><li><strong>文件的抽象形式是文件控制块File</strong>，数据则存在Block中</li><li>通过调用底层函数来操作文件对应的Block</li></ul></li></ul><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>文件服务进程使用 0x10000000 到 0x4fffffff 的地址空间作为磁盘块映射，使用 0x60000000 开始的地址作为所有进程的文件描述符表，用户进程的文件描述符是对这里的表项的共享。而用户进程使用0x60000000 之前的PDMAP再之前的 4M 空间作为文件描述符表，之后的 32（最大文件数目）* 4M 映射文件数据。</p><p>当在用户进程下打开文件时，<strong>分配 Fd 并传给文件服务进程</strong>，后者读取文件，<strong>创建 Open 结构体，复制一份文件的 File 结构体拼接成 FileFd 结构体</strong>，放在自己的全局文件描述符表中，并<strong>将这个共享给用户</strong>。用户进程收到之后将<strong>让文件服务进程映射全部数据块，并读入数据</strong>。最后的结果是文件服务进程，将分散在自己 0x10000000 到 0x4fffffff 的空间的文件的各个数据块，共享到用户进程 0x60000000 之上的属于这个文件的连续的 4M 空间之中。</p><p>关闭时，会直接将全部设置为脏，然后全部回写。如果对于打开的文件进行修改大小操作，用户进程会先改文件描述符中 File 结构体的副本，然后让文件服务进程改相应块缓存上的数据</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab4 系统调用与fork</title>
      <link href="/BUAA-SE/BUAA-OS-Lab4/"/>
      <url>/BUAA-SE/BUAA-OS-Lab4/</url>
      
        <content type="html"><![CDATA[<p>关键文件：kern&#x2F;syscall_all.c、user&#x2F;lib&#x2F;fork.c、include&#x2F;syscall.h、 user&#x2F;include&#x2F;lib.h</p><h1 id="指导书梳理"><a href="#指导书梳理" class="headerlink" title="指导书梳理"></a>指导书梳理</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="系统调用原理-步骤"><a href="#系统调用原理-步骤" class="headerlink" title="系统调用原理-步骤"></a>系统调用原理-步骤</h3><ol><li>存在一些只能由内核来完成的操作（如读写设备、创建进程、IO 等）。</li><li>C 标准库中一些函数的实现须依赖于操作系统（如我们所探究的 puts 函数）。</li><li>通过执行 syscall 指令，用户进程可以陷入到内核态，请求内核提供的服务。</li><li>通过系统调用陷入到内核态时，需要在用户态与内核态之间进行数据传递与保护。</li></ol><h3 id="系统调用机制的实现"><a href="#系统调用机制的实现" class="headerlink" title="系统调用机制的实现"></a>系统调用机制的实现</h3><p><img src="https://s2.loli.net/2024/05/08/u2oaNfZtzHrOF8e.png" alt="Untitled"></p><ul><li><p><em><strong>syscall_</strong></em>*</p><ul><li>在 MOS中， syscall_* 的函数与内核中的系统调用函数（sys_* 的函数）是一一对应的：syscall_* 的函数是用户空间中最接近的内核的函数，而sys_* 的函数是内核中系统调用的具体实现部分。</li><li>syscall_* 的函数的实现中，毫无例外都调用了 msyscall 函数，而且函数的第一个参数都是一个与调用名相似的宏（如 SYS_print_cons），MOS 中把这个参数称为<em><strong>系统调用号</strong></em>，它们被定义在 include&#x2F;syscall.h中</li></ul></li><li><p><strong>msyscall 函数——参数传递的实现</strong></p><ul><li>进入函数体时会通过对栈指针做减法（压栈）的方式为该函数自身的局部变量、返回地址、调用函数的参数分配存储空间，在函数调用结束之后会对栈指针做加法（弹栈）释放这部分空间，这部分空间称为<em><strong>栈帧</strong></em>。调用方在自身栈帧的底部预留被调用函数的参数存储空间，由被调用方从调用方的栈帧中读取参数。</li><li>寄存器 $a0-$a3 用于存放函数调用的前四个参数</li><li>剩余的参数仅存放在栈中，但在栈中仍然需要为存放在寄存器中的参数预留空间</li></ul><p>  <img src="https://s2.loli.net/2024/05/08/fveSLRpnKB4FHN7.png" alt="Untitled"></p><ul><li>系统从用户态切换到内核态后，内核首先将原用户进程的运行现场保存到内核空间（在 kern&#x2F;entry.S 中通过 SAVE_ALL 宏完成），随后<strong>内核空间的栈指针则指向保存的 Trapframe</strong>，便可以借助这个保存的结构体来获取用户态中传递过来的值</li></ul></li></ul><h3 id="基础系统调用函数"><a href="#基础系统调用函数" class="headerlink" title="基础系统调用函数"></a>基础系统调用函数</h3><p>在内核处理进程发起的系统调用时，我们并没有切换地址空间（页目录地址），也不需要将进程上下文（Trapframe）保存到进程控制块中，<strong>只是切换到内核态下，执行了一些内核代码</strong>。</p><p>可以说，处理系统调用时的内核仍然是代表当前进程的，这也是<strong>系统调用、TLB 缺失等同步异常与时钟中断等异步异常的本质区别</strong></p><h2 id="进程间通信机制-IPC"><a href="#进程间通信机制-IPC" class="headerlink" title="进程间通信机制 (IPC)"></a>进程间通信机制 (IPC)</h2><ul><li><strong>IPC的关键</strong><ul><li><p>IPC 的目的是使两个进程之间可以通信</p><p>  通俗的讲，就是把一个地址空间中的东西传给另一个地址空间</p></li><li><p>IPC 需要通过系统调用来实现</p><p>  <strong>所有的进程都共享同一个内核空间（主要为 kseg0</strong>）。因此，想要在不同空间之间交换数据，就可以借助于内核空间来实现。</p><p>  <strong>发送方进程可以将数据以系统调用的形式存放在进程控制块中，接收方进程同样以系统调用的方式在进程控制块中找到对应的数据，读取并返回</strong>。</p><p>  <img src="https://s2.loli.net/2024/05/08/agP4SRmOxqF6KB5.png" alt="Untitled"></p><p>  <img src="https://s2.loli.net/2024/05/08/PbXrGdtc2jamuJT.png" alt="Untitled"></p></li></ul></li></ul><h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p><img src="https://s2.loli.net/2024/05/08/QolHFgTN4kqDGUs.png" alt="Untitled"></p><h3 id="fork基础"><a href="#fork基础" class="headerlink" title="fork基础"></a>fork基础</h3><ul><li><p><em><strong>exec</strong></em></p><p>  与 fork 经常一起使用的是名为 exec 的一系列系统调用。它会使进程抛弃<br>  现有的程序和运行现场，<strong>执行一个新的程序</strong></p></li></ul><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>在 fork 时，我们只需将地址空间中的<strong>所有可写页标记为写时复制页面</strong>，使得在父进程或子进程对写时复制页面进行写入时，能够产生一种异常。操作系统在异常处理时，为当前进程<strong>试图写入的</strong>虚拟地址分配新的物理页面，并复制原页面的内容，最后再返回用户程序，对新分配的物理页面进行写入。</p><ul><li>进程调用 fork 时，需要对其所有的可写入的内存页面，设置页表项标志位 PTE_COW 并取消可写位 PTE_D<ul><li><p>将写时复制界面的 PTE_D 标志置为 0</p><p>  当进程读这个页面时，不会出现问题。但当进程尝试写这个页面时，由于 PTE_D 为 0，所以会触发 TLB Mod 异常，陷入内核执行写时复制流程</p></li><li><p>引入新的标志位 PTE_COW，为 1则需要进行上述的写时复制处理</p><p>  利用 TLB 项中的软件保留位，区分真正的“只读”页面和“写时复制”页面</p></li></ul></li></ul><h3 id="页写入异常"><a href="#页写入异常" class="headerlink" title="页写入异常"></a>页写入异常</h3><ul><li><p>do_tlb_mod 函数并没有进行页面复制等 COW 的处理操作。事实上，我们的 MOS 操作系统按照微内核的设计理念，<strong>尽可能地将功能实现在用户空间中</strong>，其中也包括了页写入异常的处理，因此主要的处理过程是在用户态下完成的</p></li><li><p>如果需要在用户态下完成页写入异常的处理，是不能直接使用正常情况下的用户栈的（因为发生页写入异常的也可能是正常栈的页面），所以用户进程就需要一个单独的栈来执行处理程序，我们把这个栈称作 <em><strong>异常处理栈</strong></em>，它的栈顶对应的是内存布局中的 <em><strong>UXSTACKTOP</strong></em></p></li><li><p>处理页写入异常的大致流程</p><ol><li>用户进程触发页写入异常，陷入到<strong>内核中的 handle_mod</strong>，再跳转到 do_tlb_mod 函数</li><li>do_tlb_mod 函数负责<strong>将当前现场保存在异常处理栈中</strong>，并设置 a0 和 EPC 寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场为参数，跳转到env_user_tlb_mod_entry 域存储的用户异常处理函数的地址</li><li>从异常恢复到用户态，跳转到用户异常处理函数cow_entry（fork.c 中定义）中，由用户程序完成写时复制等自定义处理。这个函数进行写时复制处理之后，使用系统调用 syscall_set_trapframe 恢复事先保存好的现场，其中也包括 sp 和 PC 寄存器的值，使得用户程序恢复执行</li></ol><p>  内核只是存相关寄存器做准备，用户进程从相关寄存器中取得需要数据进行实际处理</p></li></ul><p><img src="https://s2.loli.net/2024/05/08/ZhkaHj9XGK6ECUl.png" alt="Untitled"></p><h1 id="时纪"><a href="#时纪" class="headerlink" title="时纪"></a>时纪</h1><ul><li><p>E 4.1</p><ul><li>有傻子系统调用完不返回啊……如果没有<code>jr ra</code>，系统调用将无法正确返回结果给用户程序，用户程序可能会无限期地等待系统调用的结果，调用者无法恢复执行<ul><li>同理，也需要注意EPC的设置，比如<code>tf-&gt;cp0_epc += 4;</code> ，让返回时返回到下一条指令。而如果是延迟槽指令，epc为当前pc,不需要再加4</li></ul></li></ul></li><li><p>E 4.2</p><ul><li><p>想半天去哪个代码文件找reg的每个编号到底对应哪个寄存器，突然想起是MIPS规定好的……</p><p>  <img src="https://s2.loli.net/2024/05/08/JUnQaBZqsuYwtjF.png" alt="Untitled"></p></li></ul></li><li><p>E 4.10</p><ul><li><font color="green"><strong>修改权限位之后</strong></font>需要<strong>重新进行页面映射</strong></li></ul></li><li><p>E 4.13</p><ul><li><font color="green">注意<strong>使用alloc和map相关函数</strong>时</font>需要考虑虚拟地址页对齐的问题</li></ul></li></ul><h1 id="上机准备"><a href="#上机准备" class="headerlink" title="上机准备"></a>上机准备</h1><h3 id="需时刻注意区分用户态和内核态"><a href="#需时刻注意区分用户态和内核态" class="headerlink" title="需时刻注意区分用户态和内核态"></a>需时刻注意区分用户态和内核态</h3><ul><li>编写&#x2F;使用函数的时候需要注意，有些函数只能在内核态使用！比如page_alloc，在用户态需要换为syscall_mem_alloc来实现<ul><li><strong>使用系统调用相关函数时</strong>，注意调用<code>syscall_*</code>时的参数列表&#x2F;类型和<code>sys_*</code><strong>不一定相同</strong></li><li><strong>分配空间、建立映射时</strong>，注意考虑用 <code>page_*</code> 还是 <code>syscall_*</code></li></ul></li></ul><h3 id="常用函数-用法"><a href="#常用函数-用法" class="headerlink" title="常用函数&#x2F;用法"></a>常用函数&#x2F;用法</h3><p><font color="blue"><strong>用函数&#x2F;实现函数的第一步注意使用前提条件！</strong></font></p><ul><li><p><code>*(vpt+i) &amp; PTE_V</code> <font color="red"><strong>目录项有效性检查</strong></font></p></li><li><p><strong>vpt &amp; vpd 用法</strong></p><p>  （*vpd）[va&gt;&gt;22（页目录的索引）]&amp;(<del>0xfff) 表示二级页表的物理地址， (*vpt)[va &gt;&gt; 12]&amp;(</del>0xfff) 为 va 对应的物理页面地址，<font color="blue"><strong>使用前记得提前判断有效位</strong></font></p></li><li><p><code>envid2env</code>通过一个进程的 id 获取该进程控制块</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>is_illegal_va</code> 判断虚拟地址的有效性</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(is_illegal_va(va))&#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>*((struct Trapframe *)KSTACKTOP - 1)</code> 内核中寄存器快照的位置</p></li><li><p><code>TAILQ_INSERT_TAIL</code> 将进程插入调度队列，注意是<font color="red"><strong>TAIL</strong></font></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( env-&gt;env_status!=ENV_RUNNABLE &amp;&amp; status==ENV_RUNNABLE )&#123;</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TAILQ_REMOVE</code> 将进程移除调度队列</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br></pre></td></tr></table></figure></li><li><p><code>page_lookup</code> 写时复制时检查原页面映射是否存在</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = page_lookup( curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( p == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>perm = *(vpt+VPN(va))&amp;0xfff;</code> 获取页目录项权限</p></li><li><p><code>perm |= PTE_D;perm &amp;= ~PTE_COW;</code> 更改页目录项权限</p></li><li><p><code>user_panic</code> 用户态崩溃</p></li></ul><h3 id="往年教训"><a href="#往年教训" class="headerlink" title="往年教训"></a>往年教训</h3><ul><li>可能会<font color="green">涉及ipc的具体实现</font>，可以考虑<font color="blue">开结构体数组记录每次信息发送的相关值和一个记录是否完成的标记</font><ul><li>接收进程：首先查表，有无自己可以接受的信息，有的话就接收，设置发送进程状态为RUNNABLE 并正常退出，否则阻塞。</li><li>发送进程：检查接收进程的状态，若阻塞，直接进程信息发送同时设置接收进程状态为RUNNABLE。若接收进程没有阻塞，将待发送的信息添加到信息表中，阻塞。</li></ul></li></ul><h1 id="上机血泪教训"><a href="#上机血泪教训" class="headerlink" title="上机血泪教训"></a>上机血泪教训</h1><h2 id="extra-1"><a href="#extra-1" class="headerlink" title="extra-1"></a>extra-1</h2><ul><li><font color="green">“仿照xxx部分进行实现”，有一些部分<strong>不确定要不要保留</strong></font>就<font color="blue"><strong>先保留</strong></font>！！（很有可能涉及到一些隐性机制的实现）</li></ul><h2 id="exam-2"><a href="#exam-2" class="headerlink" title="exam-2"></a>exam-2</h2><p>“由俭入奢易，由奢入俭难“，某种程度上也适用于代码编写。<font color="red">用最<strong>简单直接精炼</strong>的代码实现，不要为求安心无脑加一些<strong>似是似非</strong>的代码</font>，容易导致一些意想不到的错误而且难找原因。一定要<font color="green"><strong>百分百确定有漏洞</strong></font>才<font color="blue"><strong>恰当地打补丁</strong></font>。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab3 进程与异常</title>
      <link href="/BUAA-SE/BUAA-OS-Lab3/"/>
      <url>/BUAA-SE/BUAA-OS-Lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="指导书梳理"><a href="#指导书梳理" class="headerlink" title="指导书梳理"></a>指导书梳理</h1><p>相关文件：<code>/include/env.h</code> <code>/include/trap.h</code> <code>/kern/env.c</code>  <code>lib/elfloader.c</code> <code>pmap.h</code>  <code>pmap.c</code>  <code>kern/traps.c</code> <code>kern/genex.S</code>  <code>kern/sched.c</code></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="模板页表（MOS专有概念）"><a href="#模板页表（MOS专有概念）" class="headerlink" title="模板页表（MOS专有概念）"></a>模板页表（MOS专有概念）</h3><p>在用户空间中读取内核信息</p><p><img src="https://s2.loli.net/2024/04/24/yIaPkFxYbjRBgW1.png" alt="Untitled"></p><ul><li><p><strong>原理</strong></p><p>  MOS 被设计成对于其中运行的每一个用户进程，都可以<strong>通过用户地址空间（kuseg）读取 pages 数组和 envs 数组的信息</strong>。为实现该功能，在创建用户进程时我们需要将 pages 数组和 envs 数组映射到用户地址空间中的 <code>UPAGES</code> 与 <code>UENVS</code> 处。</p><p>  <code>base_pgdir</code> 指向模板页表页目录的<strong>内核虚拟基地址</strong>，以便创建进程时能够根据 “模板页表” 的内容创建自己的页表。每创建一个进程，都将这个模板页表页目录中用来映射 envs 与 pages 的表项复制到新创建的进程的页目录中</p></li><li><p><strong>设置目的</strong></p><p>  使用户进程<strong>共享一部分二级页表</strong>，从而节省物理页面</p></li></ul><h3 id="进程的标识"><a href="#进程的标识" class="headerlink" title="进程的标识"></a>进程的标识</h3><p><code>struct Env</code> 进程控制块中</p><ul><li><code>env_id</code> 是每个<strong>进程</strong>独一无二的标识符，进程创建的时候就使用<code>mkenvid</code>赋予。</li><li><code>env_asid</code> 记录进程的 ASID，这是<strong>进程虚拟地址</strong>空间的标识<ul><li>ASID在TLB映射机制中使用——TLB 事实上构建了一个映射 &lt; VPN, ASID &gt;$\stackrel{TLB}{\longrightarrow}$&lt; PFN, N, D, V, G &gt;</li><li>ASID 部分只占据了 0-7 共 8 个 bit，即ASID资源是有限的，需要使用一定的资源管理方法来<strong>分配、回收</strong> ASID。MOS 实验采用了位图法管理 256 个可用的 ASID，<strong>如果 ASID 耗尽时仍要创建进程，内核会发生崩溃（panic）</strong></li></ul></li></ul><h3 id="设置进程控制块"><a href="#设置进程控制块" class="headerlink" title="设置进程控制块"></a>设置进程控制块</h3><ul><li><p>在 MOS 操作系统<strong>特意将一些内核的数据暴露到用户空间</strong>，使得进程不需要切换到内核态就能访问，这是 MOS 特有的设计</p><p>  在这里暴露 UTOP 往上到 UVPT 之间所有进程共享的<strong>只读</strong>空间，也就是把这部分内存对应的<strong>内核<br>  页表 base_pgdir 拷贝到进程页表中</strong>。从 <strong>UVPT 往上到 ULIM 之间则是进程自己的页表</strong></p><p>  <img src="https://s2.loli.net/2024/04/24/etFI7plnikVqRT6.png" alt="Untitled"></p></li></ul><h3 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h3><p>要想正确加载一个 ELF 文件到内存，只需将 ELF 文件中所有<strong>需要加载的程序段加载到对应的<font color="red">虚拟地址</font>上</strong>即可</p><p><img src="https://s2.loli.net/2024/04/24/BlTYwCyVzxOSjkP.png" alt="Untitled"></p><ul><li><code>elf_load_seg</code> 只关心ELF 段的结构，由回调函数处理具体的页面加载过程</li></ul><h3 id="进程运行与切换"><a href="#进程运行与切换" class="headerlink" title="进程运行与切换"></a>进程运行与切换</h3><p>在 Lab3 中，进程切换只需要保存进程的上下文信息。而MOS中的寄存器状态保存的地方是 <code>KSTACKTOP</code> 以下的一个 <code>sizeof(TrapFrame)</code>大小的区域中，而<code>curenv-&gt;env_tf</code>是存放当前进程的上下文的区域</p><p>故保存进程上下文使用语句<code>curenv-&gt;env_tf = *((struct Trapframe *)KSTACKTOP - 1)</code></p><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>CPU 不仅仅有常见的 32 个通用寄存器，还有功能广泛的<em><strong>协处理器</strong></em>，而中断&#x2F;异常部分就用到了其中的协处理器 CP0</p><table><thead><tr><th>寄存器助记符</th><th>CP0 寄存器编号</th><th>描述</th></tr></thead><tbody><tr><td>Status</td><td>12</td><td>状态寄存器，包括中断引脚使能，其他 CPU 模式等位域</td></tr><tr><td>Cause</td><td>13</td><td>记录导致异常的原因</td></tr><tr><td>EPC</td><td>14</td><td>异常结束后程序恢复执行的位置</td></tr></tbody></table><h3 id="Status-寄存器"><a href="#Status-寄存器" class="headerlink" title="Status 寄存器"></a><strong>Status 寄存器</strong></h3><p><img src="https://s2.loli.net/2024/04/24/OKAFgDfkURJj2S6.png" alt="Untitled"></p><ul><li><p><code>IE</code> 位表示中断是否开启，为 1 表示开启，否则不开启</p></li><li><p>当且仅当 <code>EXL</code> 被设置为 0 且 <code>UM</code> 被设置为 1 时，处理器处于<strong>用户模式</strong>，其它所有情况下，处理器均处于内核模式下</p><ul><li><p>每当异常发生的时候，EXL 会被自动设置为 1（使处于内核态，能使用特权指令）</p></li><li><p>每个进程在每一次被调度时都会执行</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RESTORE_ALL <span class="comment">//恢复处理器寄存器状态</span></span><br><span class="line">eret <span class="comment">// EXL被自动设置为 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>15-8 位为<em><strong>中断屏蔽位</strong></em>，每一位代表一个不同的中断活动，其中 15-10 位<strong>使能</strong>硬件中断源<font color="purple">（该中断能否被响应）</font>，9-8位是 Cause 寄存器软件可写的中断位</p></li></ul><h3 id="Cause-寄存器"><a href="#Cause-寄存器" class="headerlink" title="Cause 寄存器"></a>Cause 寄存器</h3><p><img src="https://s2.loli.net/2024/04/24/zi1IqLRVo5welC7.png" alt="Untitled"></p><ul><li><code>IP</code> (15-8 位)保存着哪一些中断发生了，其中 15-10 位来自硬件，9-8 位可以由软件写入，<font color="green">当 Status 寄存器中相同位允许中断（为 1）时</font>，Cause 寄存器这一位也为1就会导致中断</li><li><code>ExcCode</code> (6-2位)，记录发生了什么异常。在 MOS 中，中断是 0 号异常。</li></ul><h3 id="CPU异常处理流程"><a href="#CPU异常处理流程" class="headerlink" title="CPU异常处理流程"></a>CPU异常处理流程</h3><p>CPU 如何处理异常？</p><ol><li>设置 EPC 寄存器的值为从异常返回的地址。</li><li>设置 Status 寄存器（<strong>设置 EXL 位，强制 CPU 进入内核态并禁止中断</strong>）</li><li>设置 Cause 寄存器（记录异常原因）</li><li>设置 PC 为<strong>异常入口地址</strong>，随后交给软件处理</li></ol><p>至此，我们成功地切换到内核程序，将异常处理的任务转交给操作系统。</p><ul><li><p>相关指令</p><ul><li><p><code>mfc0</code> Move From Coprocessor 0</p><p>  用于从协处理器的某个寄存器中读取值到一个通用寄存器中</p></li><li><p><code>mtc0</code> Move To Coprocessor 0</p><p>  用于将一个通用寄存器的值写入协处理器的某个寄存器中</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mfc0    t0, CP0_STATUS</span><br><span class="line">and     t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE)</span><br><span class="line">mtc0    t0, CP0_STATUS</span><br></pre></td></tr></table></figure></li></ul><font color="grey">### SAVE_ALL 与异常重入<p>在 SAVE_ALL 中进行判断，若 Status 寄存器的 UM 位为 0，说明此次异常在内核态触发， sp 寄存器已经在内核异常栈中。不再将 sp 设置为 KSTACKTOP ，而是使其继续增长。</p><p>这样便能够在异常中处理新的异常，而不会破坏原本的异常处理流程。这一机制被称作异常重入</font></p><h3 id="异常的分发"><a href="#异常的分发" class="headerlink" title="异常的分发"></a>异常的分发</h3><p>当发生异常时，处理器会进入一个用于分发异常的程序，这个程序的作用就是检测发生了哪种异常，并调用相应的异常处理程序</p><p>一般来说，异常分发程序会被要求放在固定的某个物理地址上</p><p>在MOS中的实现为：将.text.exc_gen_entry 段和 .text.tlb_miss_entry 段用链接器放到特定的位置—— 0x80000180 和 0x80000000 处，它们是异常处理程序的入口地址。在我们的系统中，CPU 发生异常（除了用户态地址的 TLB Miss 异常）后，就会自动跳转到地址 0x80000180 处；发生用户态地址的 TLB Miss 异常时，会自动跳转到地址 0x80000000处</p><h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><ul><li><p>中断处理的流程</p><ol><li><p>通过异常分发，<strong>判断出当前异常为中断异常</strong>，随后进入相应的<strong>中断处理程序</strong>。在 MOS 中即对应 handle_int 函数。</p><p> 此前以异常的角度对时钟中断进行处理；现在以中断的角度对时钟中断进行处理</p></li><li><p>在中断处理程序中<strong>进一步判断 Cause 寄存器中是由几号中断位引发的中断</strong>，然后进入不同中断对应的<strong>中断服务函数</strong>。</p></li><li><p>中断处理完成，通过 ret_from_exception 函数<strong>恢复现场</strong>，继续执行。</p></li></ol></li><li><p>在MOS 中，<strong>时间片的长度是用时钟中断衡量</strong>的。4KC 中的 CP0 内置了一个可产生中断的 Timer，MOS 即使用这个内置的 Timer 产生时钟中断</p><p>  （具体细节实现见指导书）</p></li><li><p>内核初始化完毕后陷入死循环，等待第一次时钟中断来临，通过异常处理来调度已经创建好的用户进程运行</p></li></ul><h3 id="进程调度器"><a href="#进程调度器" class="headerlink" title="进程调度器"></a>进程调度器</h3><p><strong>什么时候需要切换进程？</strong></p><ol><li>参数 yield 为真时：此时当前进程必须让出。</li><li>count 减为 0 时：此时分给进程的时间片被用完，将执行权让给其他进程。</li><li>无当前进程：内核必然刚刚完成初始化，需要分配一个进程执行。</li><li>进程状态不是可运行：当前进程不能再继续执行，让给其他进程。</li></ol><p><strong>如何切换进程？</strong></p><ol><li>当前进程仍为就绪状态时，需要将其移到 env_sched_list 队列的尾部。</li><li>选中 env_sched_list 队列头部的进程。如果没有可用的进程，内核 panic。</li><li>设置 count 为当前进程的优先级（分配的时间片的数量）。</li></ol><p>（不管是否切换，都）最后将 count 自减 1，调用 env_run 函数。</p><h1 id="时纪"><a href="#时纪" class="headerlink" title="时纪"></a>时纪</h1><p>E 3.1</p><ul><li><p>注意链表顺序！！初始化是倒序插入</p></li><li><p><font color="red">LIST、TAIL相关宏操作的（参数）一般都是指针！！</font></p></li><li><p>如下定义</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Pde *base_pgdir;</span><br></pre></td></tr></table></figure><p>  <code>base_pgdir</code> 是一个Pde类型的指针，即为目录项的虚拟地址；</p><p>  <code>*base_pgdir</code> 是Pde类型的指针的解引用，即Pde，为目录项的物理地址</p></li></ul><p>E 3.4</p><ul><li><code>NENV</code> 什么时候要用来作为限制条件吗？这里好像不用</li></ul><p>E 3.5</p><ul><li>分配页面后记得加<code>p→pp_ref</code>！！</li></ul><p>E 3.12</p><ul><li>schedule里的count是静态变量，存放在.data区，只初始化一次，不同进程不共享！！所以虽然可能会调度多次schedule函数，但每个进程只执行一次 <code>static int count = 0;</code> 初始化语句！！</li><li>注意，不管要不要插到尾部，都要先移除当前进程！！</li></ul><h1 id="exam前准备"><a href="#exam前准备" class="headerlink" title="exam前准备"></a>exam前准备</h1><h3 id="有可能出问题"><a href="#有可能出问题" class="headerlink" title="有可能出问题"></a>有可能出问题</h3><ul><li>scheduled函数，要不要把不是就绪状态的移除</li><li>获取队列的第一个进程时，记得LIST_REMOVE</li></ul><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>近年都是处理新的异常</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab2 内存管理</title>
      <link href="/BUAA-SE/BUAA-OS-Lab2/"/>
      <url>/BUAA-SE/BUAA-OS-Lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="指导书梳理"><a href="#指导书梳理" class="headerlink" title="指导书梳理"></a>指导书梳理</h1><h2 id="内核程序启动"><a href="#内核程序启动" class="headerlink" title="内核程序启动"></a>内核程序启动</h2><ul><li><code>mips_init(u_int argc, char **argv, char **penv, u_int ram_low_size)</code><ul><li>参数是由 bootloader 传递给内核的，其中的 <code>ram_low_size</code> 参数指定了硬件可用内存大小</li></ul></li></ul><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="链表宏"><a href="#链表宏" class="headerlink" title="链表宏"></a>链表宏</h3><ul><li><p><code>LIST_ENTRY(type)</code>，作为一个特殊的类型出现，例如可以进行如下的定义：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST_ENTRY(Page) a;</span><br></pre></td></tr></table></figure><p>  它的本质是一个链表项，包括指向下一个元素的指针 <code>le_next</code>，以及<strong>指向前一个元素链表项 le_next 的</strong>指针 <code>le_prev</code>。le_prev 是一个指针的指针，它的作用是当删除一个元素时，更改前一个元素链表项的 le_next</p><p>  <img src="https://s2.loli.net/2024/04/10/AEq2lX4OTigV5cU.png" alt="Untitled"></p><ul><li>黑框框起来的是一个元素（结构体）</li><li>蓝&amp;橙部分是一个<code>LIST_ENTRY(type)</code>类型的链表项，是元素（结构体）的一个字段</li></ul></li><li><p>C 语言并没有泛型的语法，因此需要通过宏另辟蹊径来实现泛型</p></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="两级页表结构"><a href="#两级页表结构" class="headerlink" title="两级页表结构"></a>两级页表结构</h3><ul><li><p>对于一个 32 位的<strong>虚存地址</strong>，从低到高从 0 开始编号，其 <strong>31-22 位表示的是一级页表项的偏移量</strong>，<strong>21-12 位表示的是二级页表项的偏移量</strong>，11-0 位表示的是页内偏移量</p></li><li><p>页表项组成</p><p>  在 MOS 中，每个页表均由 1024 个页表项组成，每个页表项由 32 位组成，包括 20位物理页号以及 12 位标志位。<br>  高 6 位硬件标志位用于存入 EntryLo 寄存器中，供硬件使用，低 6 位软件标志位不会被存入 TLB 中，仅供软件使用。当页表项需要借助 EntryLo 寄存器填入 TLB 时，页表项会被右移 6 位，<strong>仅将高 20 位物理页号以及 6 位硬件标志位填入 TLB 使用</strong></p></li></ul><h2 id="访问内存与-TLB-重填"><a href="#访问内存与-TLB-重填" class="headerlink" title="访问内存与 TLB 重填"></a>访问内存与 TLB 重填</h2><ul><li>TLB组成：每个 TLB 表项都有两个组成部分，包括一组 Key 和两组 Data</li><li>TLB 事实上构建了一个映射 &lt; VPN, ASID &gt;$\stackrel{TLB}{\longrightarrow}$&lt; PFN, N, D, V, G &gt;。</li></ul><h3 id="EntryHi、EntryLo0、EntryLo1"><a href="#EntryHi、EntryLo0、EntryLo1" class="headerlink" title="EntryHi、EntryLo0、EntryLo1"></a>EntryHi、EntryLo0、EntryLo1</h3><p><img src="https://s2.loli.net/2024/04/10/slBHnDfZ7mbiOAx.png" alt="Untitled"></p><p>都是 CP0 中的寄存器，只是分别对应到 TLB 的 Key与两组 Data，并不是 TLB 本身。</p><ul><li>EntryLo0、EntryLo1 拥有完全相同的位结构， 分别存储 Key 对应的偶页与奇页<ul><li>4Kc 中的 TLB 采用奇偶页的设计，使用 VPN 中的高 19 位与 ASID 作为<br>  Key，一次查找到两个 Data（一对相邻页面的两个页表项），并用 VPN 中的最低 1 位在两个 Data 中选择命中的结果。因此在对 TLB 进行维护（无效化、重填）时，除了维护目标页面，同时还需要维护目标页面的邻居页面</li></ul></li><li><strong>Key——EntryHi</strong><ul><li>VPN(Virtual Page Number)<ul><li>当 TLB 缺失（CPU 发出虚拟地址，TLB 查找对应物理地址但未查到）时，EntryHi 中的 VPN **自动（由硬件）**填充为对应虚拟地址的虚页号</li><li>当需要填充或检索 TLB 表项时，<strong>软件</strong>需要将 VPN 段填充为对应的虚拟地址</li></ul></li></ul></li><li><strong>Data——EntryLo</strong><ul><li><p>PFN：Physical Frame Number</p><ul><li><strong>软件通过填写 PFN，接着使用 TLB 写指令，才可以将此时 EntryHi 中的 Key与 EntryLo 中的 Data 写入 TLB</strong></li></ul></li><li><p>D：Dirty</p><p>  事实上是可写位。当该位为 1 时，对应的页可写；否则对相应页的任何写操作都将引发 TLB 异常。</p></li><li><p>G：Global</p><p>  如果该位为 1，则 CPU 发出的虚拟地址只需要与该表项的 VPN 匹配，即可与此 TLB 项匹配成功（不需要检查 ASID 是否匹配）</p></li></ul></li></ul><h3 id="TLB-相关指令"><a href="#TLB-相关指令" class="headerlink" title="TLB 相关指令"></a>TLB 相关指令</h3><ul><li><em><strong>tlbr</strong></em>：以 Index 寄存器中的值为索引，<strong>读</strong>出 TLB 中对应的表项到 EntryHi 与 EntryLo0、EntryLo1</li><li><em><strong>tlbwi</strong></em>：以 Index 寄存器中的值为索引，将此时 EntryHi 与 EntryLo0、EntryLo1 的值<strong>写</strong>到<strong>索引指定的 TLB 表项中</strong></li><li><em><strong>tlbwr</strong></em>：将 EntryHi 与 EntryLo0、EntryLo1 的数据<strong>随机写到一个 TLB 表项中</strong>（使用 Random 寄存器来“随机”指定表项）</li><li><em><strong>tlbp</strong></em>：根据 EntryHi 中的 Key（包含 VPN 与 ASID），<strong>查找</strong> TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器（若未找到匹配项，则 Index 最高位被置 1），前后都应各插入一个 nop 以解决数据冒险</li></ul><h3 id="TLB的维护"><a href="#TLB的维护" class="headerlink" title="TLB的维护"></a>TLB的维护</h3><p>具体来说，维护 TLB 的流程如下：</p><ol><li><strong>更新页表</strong>中虚拟地址对应的页表项的同时，将 TLB 中对应的<strong>旧表项无效化</strong></li><li>在下一次访问该虚拟地址时，硬件会触发 TLB <strong>重填异常</strong>，此时操作系统对 TLB 进行重填</li></ol><h1 id="时纪"><a href="#时纪" class="headerlink" title="时纪"></a>时纪</h1><ul><li>注意检查空间是否超出了最大物理地址</li><li>E2_3<ul><li><p>LIST相关宏操作的（参数）一般都是指针啊啊啊啊！！在使用的是后如果传入的不是指针记得取地址！！</p></li><li><p>从物理地址 0x400000 开始分配物理内存，用于建立管理内存的数据结构，获取方式为</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern char end[];</span><br><span class="line">startAdd = (u_long)end;</span><br></pre></td></tr></table></figure></li><li><p><strong>循环又没写i++</strong></p></li></ul></li><li>E2_4<ul><li>异常返回值是<code>-E_NO_MEM</code> ，<strong>题目没给出去相关板块找</strong>！！（找调用了这个函数的模块，看条件判断部分，就能得知异常返回值）</li></ul></li></ul><blockquote><p>使用 tlb_invalidate 函数可以实现删除特定虚拟地址的映射，每当页表被修改，就需要调用该函数以保证下次访问相应虚拟地址时一定触发 TLB 重填，进而保证访存的正确性。<br>然而在 MOS 中，一旦物理页全部被分配，进行新的物理页分配时并不会进行任何的页面置换，而是直接返回错误，即在对应 page_alloc 函数中返回 -E_NO_MEM。</p></blockquote><ul><li>E2_6<ul><li>虚拟内存管理中的很多地址相关宏传入参数是u_long而不是指针，使用宏时注意看宏具体的实现</li><li>PTE_V 等并不是有效位的值1&#x2F;0，而是已经把1&#x2F;0填在相应位的与地址位数对齐的值（其他位为零），所以可以用 | 实现地址的生成</li><li><strong>移位运算的优先级比加法运算低</strong></li></ul></li><li>E2_7<ul><li>只要修改了页表(不管是改页面映射关系还是改权限)，就需要调用 tlb_invalidate 函数删除特定虚拟地址的映射，不然TLB和页表信息会不同步</li><li><em>va 是二级页表页面的虚拟地址！不是数据页</em></li></ul></li><li>调试出错，发现makefile错了，追根溯源，发现应该是添加注释的时候输了中文空格，造成文件出错了……</li></ul><h1 id="exam前准备"><a href="#exam前准备" class="headerlink" title="exam前准备"></a>exam前准备</h1><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><ul><li>注意<strong>有效位 <code>PTE_V</code> 的检验</strong></li></ul><h2 id="参数、宏、函数"><a href="#参数、宏、函数" class="headerlink" title="参数、宏、函数"></a>参数、宏、函数</h2><h3 id="缩写对照"><a href="#缩写对照" class="headerlink" title="缩写对照"></a>缩写对照</h3><ul><li><em><strong>Pde</strong></em> 一级页表项类型</li><li><em><strong>Pte</strong></em> 二级页表项类型</li></ul><p><img src="https://s2.loli.net/2024/04/10/XsRHS1lvuQOCez7.png" alt="Untitled"></p><h3 id="地址相互转换相关"><a href="#地址相互转换相关" class="headerlink" title="地址相互转换相关"></a>地址相互转换相关</h3><ul><li><strong>kseg0 处虚地址</strong> 与 <strong>物理地址</strong> 的转换用的是宏（PADDR、KADDR），其他基本上都是函数（pa2page等）</li></ul><h3 id="从地址中获取信息"><a href="#从地址中获取信息" class="headerlink" title="从地址中获取信息"></a>从地址中获取信息</h3><p>都是宏、在<code>mmu.h</code>中</p><h3 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h3><ul><li><p><code>pgdir_walk</code> VS <code>page_lookup</code></p><p>  都在相应的页表中找到对应的页表项，将其地址赋给*ppte</p><ul><li><code>pgdir_walk</code> 还可以<strong>创建新的页表项</strong></li><li><code>page_lookup</code> 重点在返回<strong>虚拟地址映射到的页控制块</strong></li></ul></li></ul><h1 id="Exam翻车分析"><a href="#Exam翻车分析" class="headerlink" title="Exam翻车分析"></a>Exam翻车分析</h1><h2 id="题目理解出现偏差——理解错题意-以为实现了自映射机制"><a href="#题目理解出现偏差——理解错题意-以为实现了自映射机制" class="headerlink" title="题目理解出现偏差——理解错题意&amp;以为实现了自映射机制"></a>题目理解出现偏差——理解错题意&amp;以为实现了自映射机制</h2><ul><li><p><strong>理解错题意</strong> ：*pte是页表项本身的虚拟地址，而题目里的va指的是给定的虚拟地址，要根据这个va范围内的虚拟地址到页表中去找相应的物理页框们，这个范围不是对页表项本身虚拟地址范围的限制</p></li><li><p><strong>以为实现了自映射</strong>：<strong>lab2中的内核页表并没有实现自映射机制</strong>，所以va连续且递增并不代表它们对应的pte也是连续且递增的，因此不能把va转换成pte后比较</p></li><li><p>正确的几个pte</p><p>  <img src="https://s2.loli.net/2024/09/10/34BdZzQlievqCc2.png" alt="5.png"></p></li><li><p>把va的上下界转换成pte，然后用来限制遍历的pte：因为没实现自映射，pte不像va一样连续且递增，所以pte上下界并不与va的上下界对应，导致有些正确pte会被判为不在范围内</p><p>  <img src="https://s2.loli.net/2024/09/10/kKoGrOXA4dnHERs.png" alt="6.png"></p></li></ul><h3 id="【疑问】页表在虚拟内存中不应该是连续的吗，这样怎么保证其连续性？"><a href="#【疑问】页表在虚拟内存中不应该是连续的吗，这样怎么保证其连续性？" class="headerlink" title="【疑问】页表在虚拟内存中不应该是连续的吗，这样怎么保证其连续性？"></a>【疑问】页表在虚拟内存中不应该是连续的吗，这样怎么保证其连续性？</h3><blockquote><p>展开<code>*ppte</code>表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ppte = (Pte*)(KADDR( PTE_ADDR(*pgdir_entryp) + (PTX(va)&lt;&lt;<span class="number">2</span>) ))</span><br><span class="line">= (Pte*)( page2pa(pp) + PTX(va)&lt;&lt;<span class="number">2</span> + <span class="number">0x80000000</span> )</span><br></pre></td></tr></table></figure><p>然而，根据映射机制【3】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*ppte = (Pte*)PTbase + VPN(va)</span><br><span class="line">= (Pte*)(PTbase + (VPN(va)&lt;&lt;<span class="number">2</span>))</span><br><span class="line">= (Pte*)(PTbase + ( (PDX(va)&lt;&lt;<span class="number">10</span> + PTX(va)) &lt;&lt;<span class="number">2</span>))</span><br><span class="line">= (Pte*)( PTbase + PDX(va)&lt;&lt;<span class="number">12</span> + PTX(va)&lt;&lt;<span class="number">2</span> )</span><br></pre></td></tr></table></figure><p>两者应该相等，那怎么保证下式成立呢？pp是alloc随便分配的页面啊？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page2pa(pp) + <span class="number">0x80000000</span> = PTbase + PDX(va)&lt;&lt;<span class="number">12</span> </span><br></pre></td></tr></table></figure></blockquote><p>Lab2、内核页表没有实现页表自映射，因此【3】不成立</p><h3 id="【延伸】页表到底存储在哪？"><a href="#【延伸】页表到底存储在哪？" class="headerlink" title="【延伸】页表到底存储在哪？"></a>【延伸】页表到底存储在哪？</h3><p><strong>页目录和页表都存储在kseg0</strong>。因为页表是内核数据结构，需要存储在内核这部分的区域中。内核在读写页表时，就是通过虚拟地址中的kseg0段进行的。</p><p>在lab3中，会为每个<strong>进程</strong>创建一个页表并<strong>利用kuseg实现自映射</strong>，在完成自映射后，<strong>用户进程就可以通过kuseg访问内存中自己的页表，而内核通过kseg0管理所有进程的页表</strong></p><ul><li><p>在某些操作系统中，会分进程页表和内核页表，可以理解为内核页表用于内存的实际管理，而进程页表是一种方便用户查阅的机制。</p><p>  MOS的设计中，内核自身没有页表</p></li></ul><h2 id="代码编写（指针使用）不够规范"><a href="#代码编写（指针使用）不够规范" class="headerlink" title="代码编写（指针使用）不够规范"></a>代码编写（指针使用）不够规范</h2><ul><li><font color='red'><strong>指针解引用前必须先验证其非NULL，野指针会导致卡死</strong></font></li></ul>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OS-Lab1 内核、启动和 PRINTF</title>
      <link href="/BUAA-SE/BUAA-OS-Lab1/"/>
      <url>/BUAA-SE/BUAA-OS-Lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="指导书梳理-讲解"><a href="#指导书梳理-讲解" class="headerlink" title="指导书梳理&amp;讲解"></a>指导书梳理&amp;讲解</h1><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><ul><li><p>阅读意义：对整个操作系统的布局产生初步了解</p></li><li><p>多种赋值语句</p><ul><li><p><code>=</code> 赋予<strong>整个</strong>makefile中<strong>最后被指定</strong>的值</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VIR_A = A</span><br><span class="line">VIR_B = <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A = AA</span><br><span class="line"><span class="comment"># 最后VIR_B的值是AA B</span></span><br></pre></td></tr></table></figure></li><li><p><code>:=</code> 赋予<strong>当前位置</strong>的值</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VIR_A := A</span><br><span class="line">VIR_B := <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A := AA</span><br><span class="line"><span class="comment"># 最后VIR_B的值是A B</span></span><br></pre></td></tr></table></figure></li><li><p><code>?=</code> 如果该变量没有被赋值，则赋予等号后的值</p></li></ul></li><li><p><code>.PHONY</code> 表明列在其后的目标不受修改时间的约束，无视 make 时有关时间戳的性质</p><ul><li>时间戳检查是指在进行编译时，通过比较文件的时间戳来确定是否需要重新生成目标文件。时间戳检查是实现<strong>增量编译</strong>的核心原理，它能够有效地避免不必要的重复编译，提高编译效率</li></ul></li><li><p>构建整个项目依赖于构建好<strong>内核可执行文件</strong> $(mos_elf)，后者的构建依赖于<strong>所有的模块</strong></p><p>  <img src="https://s2.loli.net/2024/03/27/wexCUBDZ3SkMJVI.png" alt="顶层Makefile片段"></p><p>  顶层Makefile片段</p><ul><li>内核可执行文件构建：调用<strong>链接器</strong>将之前构建各模块产生的所有 .o文件在 <strong>linker script</strong> 的指导下链接到一起</li><li>每个模块的构建：调用对应模块目录下的 Makefile</li></ul></li></ul><h3 id="ELF-Executable-and-Linkable-Format-文件"><a href="#ELF-Executable-and-Linkable-Format-文件" class="headerlink" title="ELF (Executable and Linkable Format)文件"></a>ELF (Executable and Linkable Format)文件</h3><ul><li><p>反汇编并将结果导出至文本文件的命令如下</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -DS 要反汇编的目标文件名 &gt; 导出文本文件名</span><br></pre></td></tr></table></figure></li><li><p>ELF 的文件头，就是一个存了关于 ELF 文件信息的结构体。</p><ul><li>存储ELF 的<strong>魔数</strong>，以验这是一个有效的 ELF<ul><li><font color="blue">是判断ELF文件的条件，不应该通过扩展名判断</font></li></ul></li></ul></li><li><p>有一个随编译工具链提供的工具也名为 readelf</p><ul><li><code>readelf -S</code> 以列表的形式输出文件中各个节的详细信息</li><li><code>readelf -l</code> 查看各个段的信息</li></ul></li></ul><h3 id="MIPS-内存布局——寻找内核的正确位置"><a href="#MIPS-内存布局——寻找内核的正确位置" class="headerlink" title="MIPS 内存布局——寻找内核的正确位置"></a><strong>MIPS</strong> 内存布局——寻找内核的正确位置</h3><ul><li><p>MIPS 内存布局见<a href="https://www.notion.so/e7b93d6565484418ac890f70428f06ea?pvs=21">理论部分</a></p></li><li><p>内存布局图内存部分</p><p>  <img src="https://s2.loli.net/2024/03/27/mM3uwj6BtQZRipP.png" alt="Untitled"></p><ul><li>为<strong>异常处理</strong>预留一块空间</li><li>将<strong>内核镜像</strong>的 .text 、 .data 、 .bss 这些节安置在 0x80020000</li><li>为<strong>栈</strong>预留一块空间，将基地址设置为 0x80400000（栈是从高地址向低地址生长的）</li></ul></li></ul><h3 id="Linker-Script-——-控制加载地址"><a href="#Linker-Script-——-控制加载地址" class="headerlink" title="Linker Script —— 控制加载地址"></a>Linker Script —— 控制加载地址</h3><p>链接器控制了输出文件的内存布局</p><ul><li><p><font color="blue">语法</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment"># . 表示定位计数器，规定当前的位置</span></span><br><span class="line"> . = 0x10000;</span><br><span class="line"> .text : &#123; *(.text) &#125;</span><br><span class="line"> . = 0x8000000;</span><br><span class="line"> .data : &#123; *(.data) &#125;</span><br><span class="line"> .bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在 Linker Script 中可以通过 ENTRY(symbol) 来设置程序入口（程序执行的第一条指令）</span></span><br></pre></td></tr></table></figure><ul><li>注意这里 &#x3D; 两边有空格</font></li></ul></li></ul><h2 id="从零开始搭建-MOS"><a href="#从零开始搭建-MOS" class="headerlink" title="从零开始搭建 MOS"></a>从零开始搭建 <strong>MOS</strong></h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">targets := <span class="variable">$(mos_elf)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(targets)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(modules)</span>:</span><br><span class="line"><span class="variable">$(MAKE)</span> --directory=<span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(mos_elf)</span>: <span class="variable">$(modules)</span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$(mos_elf)</span> -N -T <span class="variable">$(link_script)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><ul><li>链接命令参数<ul><li><code>-T</code> 指定链接脚本</li></ul></li></ul><h3 id="start-函数"><a href="#start-函数" class="headerlink" title="_start 函数"></a><strong>_start</strong> 函数</h3><ul><li>EXPORT 宏：<code>EXPORT(_start)</code>将 _start 函数导出为一个符号，使得链接器可以找到它。可以简单的理解为，它实现了一种在汇编语言中的函数定义</li></ul><h2 id="实战-printk"><a href="#实战-printk" class="headerlink" title="实战 printk"></a>实战 <strong>printk</strong></h2><h3 id="处理变长参数表"><a href="#处理变长参数表" class="headerlink" title="处理变长参数表"></a>处理变长参数表</h3><ul><li><p>常用宏和变量类型</p><ul><li><code>va_list</code>变长参数表的变量类型</li><li><code>va_start(va_list ap, lastarg)</code>初始化变长参数表，lastarg为该函数最后一个命名的形式参数</li><li><code>va_arg(va_list ap, 类型)</code>取变长参数表下一个参数<ul><li>由于<strong>类型提升</strong>的存在，C 语言中的数值类型在作为右值使用（如参与算术运算、作为实参传递等）时往往都会发生提升(表达式中的字符和短整型操作数在使用之前被转换为普通整型)</li><li>变长参数是通过<strong>栈空间</strong>实现的。由于需要确定后续参数的地址，所以每次取参数都需要<strong>标明类型</strong></li></ul></li><li><code>va_end(va_list ap)</code>结束使用变长参数表</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line"> <span class="comment">// 声明一个类型为 va_list 的变量 ap</span></span><br><span class="line"> va_list ap;</span><br><span class="line"> <span class="comment">// 用 va_start 宏进行一次初始化</span></span><br><span class="line"> va_start(ap, fmt);</span><br><span class="line"> vprintfmt(outputk, <span class="literal">NULL</span>, fmt, ap);</span><br><span class="line"> va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>void vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap)</code></p><ul><li><p>out</p><p>  回调函数,完成输出。实现解析逻辑和输出逻辑的解耦，同时 printk 等上层函数可传入不同的回调函数实现不同的输出行为（比如输出到文件）</p></li><li><p>data</p><p>  是回调函数 out 需要的额外上下文信息</p></li><li><p>可以类比面向对象语言中的设计，将 out 视为“继承自接口的方法实现”， data 则类似方法中的 this 指针</p></li></ul></li></ul><h1 id="实验代码阅读-常用操作"><a href="#实验代码阅读-常用操作" class="headerlink" title="实验代码阅读&amp;常用操作"></a>实验代码阅读&amp;常用操作</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>本章主要使用</p><ul><li><p>include目录——存放系统头文件</p><ul><li><p>mmu.h</p><p>  有一张内存布局图，在<font color="green">填写 linker script</font> 的时候需要<strong>根据这个图设置相应节的加载地址</strong></p></li></ul></li><li><p>include.mk</p></li><li><p>init目录——初始化内核相关代码</p><ul><li><p>start.S</p><ul><li><p>_start 函数</p><p>  是 CPU 控制权被转交给内核后执行的<strong>第一个函数</strong>，主要工作是初始化 CPU 和栈指针，然后跳转至 MOS 的初始化函数（ mips_init ）</p><p>  内核栈空间的地址可以在 include&#x2F;mmu.h 中看到，<font color="red">注意栈的增长方向</font></p></li></ul></li><li><p>init.c</p><ul><li><p>mips_init 函数</p><p>  内核中<strong>各模块的初始化函数</strong>都会在这里被调用</p></li></ul></li></ul></li><li><p>kern目录——存放内核的主体代码</p><p>  本章中主要存放的是终端输出相关的函数</p><ul><li><p>machine.c——往 QEMU 的控制台输出字符</p><p>  原理为读写某一个特殊的内存地址</p></li><li><p>printk.c——实现了 printk</p><p>  实际上是把输出字符的函数，接受的输出参数给传递给了 vprintfmt 这个函数</p></li></ul></li><li><p>kernel.lds</p></li><li><p>lib目录——存放一些常用库函数</p><p>  本章中主要存放用于格式化输出的函数</p><ul><li>print.c——实现了 vprintfmt 函数(实现了格式化输出的主体逻辑)</li></ul></li><li><p>Makefile</p></li><li><p>mk目录</p></li><li><p>tests目录——存放公开的测试用例</p></li><li><p>tools目录</p><ul><li>readelf目录<ul><li><p>elf.h ——存放解析ELF文件要用的三个关键数据结构</p><ul><li>包括三个结构体，第一个对应ELF 的文件头，第二个对应节（section）头表，第三个对应段（segment）头表</li></ul></li><li><p>readelf.c ——用于解析ELF文件</p><ul><li>is_elf_format函数——判断输入是否为ELF文件</li><li>readelf 函数——输出 ELF 文件中所有节头中的地址信息</li></ul></li></ul></li></ul></li></ul><h2 id="make的使用"><a href="#make的使用" class="headerlink" title="make的使用"></a>make的使用</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li><p><code>make</code> 编译完整内核</p><ul><li>需要在init&#x2F;init.c的mips_init里添加自己的测试代码</li></ul></li><li><p><code>make test lab=&lt;x&gt;_&lt;y&gt;</code>编译指定测试点， lab<x> 的第 y 个测试用例</p><p>  eg make test lab&#x3D;1_2</p></li></ul><h3 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h3><ul><li><code>make run</code> 运行</li><li><code>make dbg</code> 使用 QEMU 模拟器以调试模式运行内核，并进入 GDB 调试界面。</li><li><code>make objdump</code> 将项目中的目标文件反汇编</li><li><code>Ctrl+A+X</code> 退出 QEMU</li></ul><h1 id="Lab0实时记录"><a href="#Lab0实时记录" class="headerlink" title="Lab0实时记录"></a>Lab0实时记录</h1><ul><li>设置32位地址要使用<code>ori</code>+<code>lui</code>指令</li><li>用gitlab IDE编辑提交之后，切回跳板机运行前记得<code>git pull</code>！！</li></ul><h1 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="对“数据类型”的理解"><a href="#对“数据类型”的理解" class="headerlink" title="对“数据类型”的理解"></a>对“数据类型”的理解</h3><p>在ELF文件的解析过程中，用到了3个重要的结构体，相当于定义了3种新的数据类型（实际不止3种，其他部分代码里也有定义）。</p><p>而在实际编写中，就涉及到数据类型的转换。比如在做Exercise 1.1的时候*，*把 void *类型的 binary  强制转换为了 ELF32_Ehdr * 。</p><p>因为此前对于数据类型的理解不够灵活，导致我理解这一部分花了好些时间。我认为这里的理解关键在于，**数据类型并不是某段内存数据的固有属性，而是对它的解释方式。**只要符合类型的大小和对齐要求，就可以把这段数据看做某种类型。</p><p>需要注意的是，<strong>指针的相关操作</strong>与数据类型是密切相关的，比如指针的++操作，增加的是<code>sizeof（数据类型）</code></p><h3 id="较复杂函数的参数表示、实现逻辑与调用关系梳理"><a href="#较复杂函数的参数表示、实现逻辑与调用关系梳理" class="headerlink" title="较复杂函数的参数表示、实现逻辑与调用关系梳理"></a>较复杂函数的参数表示、实现逻辑与调用关系梳理</h3><p>在这次lab中指的就是vprintfmt相关函数</p><ul><li><p>首先要搞明白每个参数的意义</p><p>  完成Exercise 1.4花费了我不少时间，因为一开始我对各函数参数的意义完全是一头雾水，就比如vprintfmt参数列表中的data是什么？ap这一可变参数又是哪些参数？</p><p>  指导书上没有直接的答案，我想课程组正是在锻炼我们在现有资料基础上自主理解代码的能力。</p><p>  （后续经验总结见“实验体会”部分）</p></li><li><p>然后要明确特定函数的实现逻辑</p><p>  其实在本次实验中，我认为这不是一个难点，因为指导书中将vprintfmt相关函数的具体实现逻辑（流程）解释得很清楚了，而且代码填空部分的实现步骤也划分得很细，每一步还有详细的注释。</p><p>  但以后的实验，或者未来我们自己实际开发项目时，很难再有这种“手把手”的指导。<font color="blue">我们需要自己学着像指导书一样梳理清楚实现逻辑，像代码填空一样把逻辑拆解为一步步可实现的步骤。</font></p></li><li><p>还需要搞清楚多模块&#x2F;函数之间的调用关系</p><p>  <img src="https://s2.loli.net/2024/03/27/51cexIQNsh9omXD.png" alt="Exercise 1.4 相关函数调用关系"></p><p>  Exercise 1.4 相关函数调用关系</p></li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><h3 id="实验代码阅读与把握"><a href="#实验代码阅读与把握" class="headerlink" title="实验代码阅读与把握"></a>实验代码阅读与把握</h3><ul><li><p>整体结构把握</p><ul><li><p><font color="blue">把握好顶层架构</font></p><p>  为什么这样划分文件结构？每部分文件的作用是什么？它们怎么协同？弄明白了这些问题，才能更顺利地编码</p><p>  <img src="https://s2.loli.net/2024/03/27/ayHJbiKSYlG7w1C.png" alt="截止lab1的文件架构梳理"></p><p>  截止lab1的文件架构梳理</p></li><li><p><font color="blue">用好外部变量</font></p><p>  很多时候<font color="green">要用的量和想实现的功能</font>在相应的文件中都有宏定义或者函数定义。所以先阅读文件，找不到再自己写</p></li></ul></li><li><p>具体参数意义理解</p><ul><li><p><font color="blue">通过检索的方式在指导书、讲解PPT等多处资源中广泛找思路</font></p><ul><li><p>比如<code>vprintfmt</code>参数列表中的<code>data</code>是什么？</p><p>  指导书中没有说明，但讲解PPT中讲的很清楚。不要纠结与单一资料，学会广泛检索。</p></li></ul></li><li><p><font color="blue">通过阅读并理解更大范围（比如完整函数、上层调用函数）代码段，明白本质，进而把握单个参数意义</font></p><ul><li><p>比如<code>vprintfmt</code>参数列表中<code>ap</code>这一可变参数指的是哪些参数？</p><p>  <code>vprintfmt</code>函数实现的是格式化输出的主体逻辑，被<code>printk</code>调用，参数列表中的ap参数也是从上层函数中得来。结合<code>printk</code>的用法，比如<code>printk(&quot;%d%c%ld&quot;, a, b, c)</code>，很容易明白可变参数就是需要输出的一系列变量，而<code>fmt</code>就是引号中的字符串。</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OS-Lab0 Linux基础操作</title>
      <link href="/BUAA-SE/BUAA-OS-Lab0/"/>
      <url>/BUAA-SE/BUAA-OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="讲解部分梳理"><a href="#讲解部分梳理" class="headerlink" title="讲解部分梳理"></a>讲解部分梳理</h1><h2 id="Linux-基本操作"><a href="#Linux-基本操作" class="headerlink" title="Linux 基本操作"></a>Linux 基本操作</h2><ul><li><code>head</code> 输出文件首部内容<ul><li><code>-n &lt;n&gt;</code> 显示前 <n> 行内容</li><li><code>-c &lt;n&gt;</code> 显示前 <n> 个字节内容</li></ul></li><li><code>tail</code> 输出文件尾部内容<ul><li><code>-n &lt;n&gt;</code> 显示末尾 <n> 行内容</li><li><code>-c &lt;n&gt;</code> 显示末尾 <n> 个字节内容</li><li><code>-f</code> 当文件增长时，输出后续添加的数据（适用于文件不断变化的情况，如日志文件）</li></ul></li><li><code>ps</code> 显示当前进程状态<ul><li><code>-aux / -ef</code> 显示所有进程</li></ul></li><li><code>mv</code> 还可以用于重命名</li><li>递归参数<ul><li><code>-p</code> <strong>从指定目录向上级目录递归</strong> eg 创建目录</li><li><code>-r</code> <strong>从指定目录向其下级目录递归</strong> eg 递归删除、拷贝</li></ul></li><li>在命令后加上<code>&amp;</code>符号，代表让命令在后台进行</li><li><code>Ctrl Q</code> 进入块选模式，方便删注释和缩进<ul><li>选择之后可以通过 <code>I</code> 进入插入模式，方便段落缩进</li><li><code>&#123;</code> <code>&#125;</code> 向上&#x2F;下选中 1 段</li></ul></li></ul><h2 id="Makefile-补充"><a href="#Makefile-补充" class="headerlink" title="Makefile 补充"></a>Makefile 补充</h2><ul><li><p>开头最好写<code>.PHONY xx</code> (一般会写<code>.PHONY：clean</code>）</p><ul><li><code>.PHONY</code>后面跟的目标都被称为伪目标，对应的命令一定会被执行</li><li>作用：避免伪目标同名文件冲突；提高执行效率</li></ul></li><li><p>每一个指令 (command) 之前<strong>必须按一次制表符键</strong>来控制间隔，而不能是空格，否则 make 会报错</p></li><li><p>简洁高效的写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用变量维护Makefile</span></span><br><span class="line"><span class="comment"># %.o: %.c 缩小编写量</span></span><br><span class="line">CC = gcc</span><br><span class="line">OBJ = function.o test.o</span><br><span class="line">TARGET = test</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(OBJ)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p>外层 makefile 调用内层 makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all：</span><br><span class="line">    <span class="variable">$(MAKE)</span> -C subdir</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> clean -C subdir</span><br></pre></td></tr></table></figure></li></ul><h2 id="Git-补充"><a href="#Git-补充" class="headerlink" title="Git 补充"></a>Git 补充</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a><code>git branch</code></h3><p><code>git branch &lt;branch-name&gt;</code> 本地创建一个基于当前分支产生的分支。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><strong><code>git status</code></strong></h3><p><strong>查看当前分支的状态</strong>，以及当前工作区的变动和暂存区的内容</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><strong><code>git add</code></strong></h3><p>把一个<strong>新文件</strong>或者已经<strong>修改过的文件</strong>加入<strong>暂存区</strong>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_name&gt;         <span class="comment"># 将指定文件加入暂存区</span></span><br><span class="line">git add .                   <span class="comment"># 或使用.将项目所有文件加入暂存区（除.gitignore指定的文件外）</span></span><br></pre></td></tr></table></figure><h3 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a><strong><code>git restore</code></strong></h3><p>放弃修改（如果涉及到文件的增删，建议用 reset，用的时候慎重）</p><ul><li>当文件还没有通过  <code>git add</code>  加入暂存区时，使用  <code>git restore &lt;filename&gt;</code>  来撤销修改，使其退回到上一个 commit 的状态</li><li>如果文件已经加入了暂存区，通过  <code>git restore **--staged** &lt;filename&gt;</code>  来取消暂存。</li><li><strong>其他错误回退命令</strong><ul><li>若文件未添加至暂存区：使用  <code>git checkout &lt;filename&gt;</code>  将文件替换成暂存区版本，或  <code>git checkout .</code>  将工作区内的所有文件替换成暂存区内的文件（谨慎使用）</li><li>若文件已添加到暂存区但未提交到本地仓库：使用  <code>git reset HEAD .</code>  撤销暂存区的所有修改至工作区，接下来就回到了上一步</li><li>若已提交到本地仓库：使用  <code>git reset --hard HRAD^</code>  将所有文件回退至上一版本</li></ul></li></ul><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><strong><code>git reset</code></strong></h3><p><code>git reset --hard</code> 可以<strong>恢复文件的版本</strong>，既可以往旧版本恢复，也可以往新版本“恢复”。但–hard 是 reset 命令唯一的危险用法，使用时如果工作区的文件还未提交，git 会覆盖它从而导致无法恢复。所以使用时要<strong>小心谨慎</strong></p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><strong><code>git checkout</code></strong></h3><p><strong>切换分支</strong></p><p>注意，在切换时，需要<strong>保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）</strong></p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><strong><code>git commit</code></strong></h3><p>使用  <code>git commit -m &lt;message&gt;</code>  这个命令将暂存区的修改提交到储存库中。<strong>当 message 参数有空格时需要把 message 用引号括起来</strong></p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a><code>git rm</code></h3><ul><li>加<code>--cached</code> 从暂存区删除，但不删除工作区文件，不加则两边都删</li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p><code>git branch -d(D) &lt;branch-name&gt;</code> 删除本地对应分支</p><p><code>git push origin --delete [branch_name]</code> 删除远程分支</p><h3 id="建立孤儿分支"><a href="#建立孤儿分支" class="headerlink" title="建立孤儿分支"></a>建立孤儿分支</h3><ol><li><code>git checkout --orphan &lt;branch name&gt;</code> 创建孤立分支</li><li><code>git rm -rf .</code> 删除拷贝的所有文件</li><li><code>touch add commit</code></li><li><code>git push -u origin &lt;branch name&gt;</code> 创建远程分支并将其关联</li></ol><h3 id="提交空文件夹"><a href="#提交空文件夹" class="headerlink" title="提交空文件夹"></a>提交空文件夹</h3><p>Git 只对跟踪文件进行版本控制，而不跟踪文件夹本身。如果想要提交一个空文件夹到 Git 仓库中，可以<strong>在文件夹中添加一个占位文件</strong>，例如“.gitkeep”</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p><code>git merge</code> 自动合并</p><ul><li>如果自动合并不成功（存在冲突）<ul><li>不想继续合并了，退出合并的中间状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure></li><li>处理冲突 <strong>最好在图形化界面上解决，更方便</strong><ol><li><code>git status</code>查看冲突的文件</li><li>编辑冲突文件，解决冲突（记得删除三行分隔线）</li><li><code>git add 冲突文件</code></li><li><code>git commit -m &quot;提交信息&quot;</code></li></ol></li></ul></li></ul><h2 id="文本处理三剑客"><a href="#文本处理三剑客" class="headerlink" title="文本处理三剑客"></a>文本处理三剑客</h2><h3 id="grep-查找"><a href="#grep-查找" class="headerlink" title="grep 查找"></a>grep 查找</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] PATTERN FIL</span><br><span class="line">选项（常用）：</span><br><span class="line">-a 不忽略二进制数据进行搜索。</span><br><span class="line">-i 忽略大小写差异。</span><br><span class="line">-r 从目录中递归查找。</span><br><span class="line">-n 显示行号</span><br><span class="line">-q 安静模式，不打印结果</span><br></pre></td></tr></table></figure><h3 id="sed-替换、删除等"><a href="#sed-替换、删除等" class="headerlink" title="sed 替换、删除等"></a>sed 替换、删除等</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] <span class="string">&#x27;命令&#x27;</span> 输入文本</span><br><span class="line">选项（常用）：</span><br><span class="line">-n：安静模式，只显示经过sed处理的内容。否则显示输入文本的所有内容。</span><br><span class="line">**-i：直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。</span><br><span class="line">-E 选项用于启用扩展正则表达式,这样我们就可以使用更加灵活的正则表达式语法。**</span><br><span class="line">命令（常用）：</span><br><span class="line">[行号]a[内容]：新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，</span><br><span class="line"> 也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一</span><br><span class="line"> 行之后新增。使用$表示最后一行。后面的命令同理。</span><br><span class="line">[行号]c[内容]：取代。用内容取代相应行的文本。</span><br><span class="line">[行号]i[内容]：插入。在当前行的上面插入一行文本。</span><br><span class="line">[行号]d：删除当前行的内容。</span><br><span class="line">[行号]p：输出选择的内容。通常与选项-n一起使用。</span><br><span class="line">s/re（正则表达式）/string(/g)：将re匹配的内容替换为string /g表示全文替换，不加则替换第一个</span><br></pre></td></tr></table></figure><h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$1&gt;2 &#123;print $1,$3&#125;&#x27;</span> my.txt</span><br><span class="line"><span class="comment"># awk &#x27;pattern action&#x27; file ，pattern 为条件，action 为命令，file 为文件</span></span><br><span class="line"><span class="comment"># 命令中出项的 $n 代表每一行中用空格分隔后的第 n 项</span></span><br><span class="line"><span class="comment"># 该命令的意义是文件 my.txt 中所有第一项大于 2 的行，输出第一项和第三项</span></span><br><span class="line"></span><br><span class="line">awk -F, <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> my.txt</span><br><span class="line"><span class="comment"># -F 选项用来指定用于分隔的字符，默认是空格</span></span><br><span class="line"><span class="comment"># 该命令的意义是打印用 , 分隔后的第 2 项</span></span><br><span class="line"></span><br><span class="line">grep -n <span class="string">&quot;all&quot;</span> my.txt &gt; result.txt</span><br><span class="line"><span class="comment"># 打印含有“all”的行并显示行号</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&quot;s/<span class="variable">$2</span>/<span class="variable">$3</span>/g&quot;</span> <span class="variable">$1</span></span><br><span class="line"><span class="comment"># 将传入的第一个参数（文件）里的所有 第二个参数 替代为 第三个参数</span></span><br></pre></td></tr></table></figure><h2 id="shell-编程注意"><a href="#shell-编程注意" class="headerlink" title="shell 编程注意"></a>shell 编程注意</h2><ul><li><p>首句<code>#!/bin/bash</code></p></li><li><p>等号与运算符两边不允许有空格，<code>-op</code>的两边与<code>[]</code>内部两边必须有空格</p><ul><li><code>[</code> 实际是一个可执行程序</li><li>双中括号同样用于判断条件，比单中括号更高级。例如在双中括号中可以直接使用逻辑运算：<code>[[ $a -gt 1 &amp;&amp; $a -lt 100 ]]</code>，而使用单中括号只能写为<code>[ $a -gt 1 ] &amp;&amp; [ $a -lt 100 ]</code></li></ul></li><li><p>获取变量值建议使用 <code>$&#123;var&#125;</code>，花括号避免歧义</p></li><li><p>引用变量必须在<strong>双引号</strong>中进行</p></li><li><p><code>$#</code> 传递的参数个数；<code>$*</code> 一个字符串，内容是传递的全部参数</p></li><li><p><code>let</code> 赋值运算 eg <code>let i=i+1</code> 等价于 <code>i=$(($i+1))</code> （双括号是计算值）</p></li><li><p>流程控制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 表达式1 ]; <span class="keyword">then</span></span><br><span class="line">命令列表1;</span><br><span class="line"><span class="keyword">elif</span> [ 表达式2 ]; <span class="keyword">then</span></span><br><span class="line">命令列表2;</span><br><span class="line"><span class="keyword">else</span> [ 表达式3 ]; <span class="keyword">then</span></span><br><span class="line">命令列表3;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 表达式 ];<span class="keyword">do</span></span><br><span class="line">命令列表;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> [参数列表];<span class="keyword">do</span></span><br><span class="line">命令列表;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#最后都有done</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h1><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p><strong>在评测前先确保自己对于文件的变更已经全部添加到暂存区</strong>（使用合适的  <code>git add</code>  和  <code>git commit</code> ）！！<strong>注意先<code>add</code>再<code>commit</code></strong> ，新建的文件需要先添加跟踪才会到暂存区，才能用<code>commit</code>提交。</p><ul><li>整型转字符串 <code>sprintf</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str)</span><br></pre></td></tr></table></figure></li><li>三剑客不熟悉</li><li>变量使用忘了<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自增操作！</span><br><span class="line"><span class="comment">#错误写法</span></span><br><span class="line">a=a+1</span><br><span class="line"><span class="comment">#正确写法</span></span><br><span class="line">a=$[<span class="variable">$a</span>+1]</span><br></pre></td></tr></table></figure></li><li>在 sed 命令中<ul><li><strong>使用变量</strong>时，<strong>正则用双引号</strong>（一般只能用单引号）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=tomas</span><br><span class="line">sed -i <span class="string">&quot;s/rose/<span class="variable">$&#123;name&#125;</span>/g&quot;</span> name.txt</span><br></pre></td></tr></table></figure><ul><li>单引号<code>‘’</code><ul><li>括起来的字符均作为普通字符出现</li></ul></li><li>双引号<code>“”</code><ul><li>括起来的字符除 <code>$</code>、<code>\</code>、<code>‘’</code>、和 <code>“”</code> 之外都将作为普通字符对待，所以如果要用变量值就要用<code>“”</code></li></ul></li><li>倒引号&#96;&#96;&#96;&#96;<br>用于命令替换，其所括字符串在被 Shell 解释时，首先执行其中的命令并将其结果代替该命令</li><li>$俩小括号&#x2F;$中括号<strong>计算结果</strong>替换，$单小括号<strong>执行结果</strong>替代</li></ul></li><li>要更改源文件内容要加参数<code>-i</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换字符串，并更改原文件内容</span></span><br><span class="line"><span class="comment"># 在sed后面加 -i,即编辑文档“edit files in place”选项</span></span><br></pre></td></tr></table></figure></li></ul></li><li>gcc 编译时如果头文件不在<code>/usr/include</code>里，一定记得<code>-I &lt;头文件所在位置路径&gt;</code></li></ul><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h3 id="Linux-下命令种类多，参数复杂"><a href="#Linux-下命令种类多，参数复杂" class="headerlink" title="Linux 下命令种类多，参数复杂"></a>Linux 下命令种类多，参数复杂</h3><ul><li><code>ls</code>、<code>mv</code>、<code>touch</code>等常用命令倒是能熟练掌握，但像<code>sed</code>、<code>awk</code>等参数复杂功能复杂的命令，在使用时就容易一下想不起来正确的使用方法</li><li><font color="Blue">解决方法：先通过多练习熟练，使用时若不确定先查阅资料或参考书</font></li></ul><h3 id="shell-编程中符号和空格使用非常容易出错"><a href="#shell-编程中符号和空格使用非常容易出错" class="headerlink" title="shell 编程中符号和空格使用非常容易出错"></a>shell 编程中符号和空格使用非常容易出错</h3><p>比如</p><ul><li>各种引号的使用<ul><li>单引号<code>‘’</code><br>括起来的字符均作为普通字符出现</li><li>双引号<code>“”</code><br>括起来的字符除 <code>$</code>、<code>\</code>、<code>‘’</code>、和 <code>“”</code> 之外都将作为普通字符对待，所以如果要用变量值就要用<code>“”</code></li><li>倒引号&#96;&#96;&#96;&#96;<br>用于命令替换，其所括字符串在被 Shell 解释时，首先执行其中的命令并将其结果代替该命令</li></ul></li><li>各种括号的使用<ul><li><code>$(())</code>&#x2F;<code>$[]</code><strong>计算结果</strong>替换，<code>$()</code><strong>执行结果</strong>替代</li></ul></li><li>空格的使用<ul><li>等号与运算符两边不允许有空格，<code>-op</code>的两边与<code>[]</code>内部两边必须有空格</li></ul></li></ul><h3 id="Makefile-嵌套"><a href="#Makefile-嵌套" class="headerlink" title="Makefile 嵌套"></a>Makefile 嵌套</h3><ul><li>makefile 嵌套的写法有很多，用<code>$(Make) -C subdir</code> （<code>-C</code> 是跳转到指定路径再执行 make 操作） 或者 <code>cd subdir &amp;&amp; make</code> 都可以，需要特别注意不要用混了</li><li>用<code>$(Make)</code>这种操作时想要做 make clean，是<code>$(MAKE) clean -C subdir</code></li><li><code>gcc</code>编译时如果依赖的库文件不在本文件夹下，要记得用<code>-I</code>进行链接</li><li>注意相对路径和绝对路径的使用要准确</li></ul><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><h3 id="编写-Shell-脚本和-make-文件时熟练度至关重要"><a href="#编写-Shell-脚本和-make-文件时熟练度至关重要" class="headerlink" title="编写 Shell 脚本和 make 文件时熟练度至关重要"></a>编写 Shell 脚本和 make 文件时熟练度至关重要</h3><p>虽然上学期学习了系统编程，有了一定的编写 Shell 脚本和 make 文件的基础。但由于课后自主训练较少，加上假期疏于复习，导致对相关操作并不完全熟练。但 Shell 脚本和 make 文件的编写是在 Linux 环境下顺利进行实验的基础，因此需要在课后多多练习，尽快熟悉相关操作，以免后续实验中因基础操作不熟练浪费时间</p><h3 id="debug-时利用好讨论区-利用好git操作"><a href="#debug-时利用好讨论区-利用好git操作" class="headerlink" title="debug 时利用好讨论区 &amp; 利用好git操作"></a>debug 时利用好讨论区 &amp; 利用好<code>git</code>操作</h3><p>Excecise1 测评错误后，一直以为是自己哪里写错，反复检查每个文件，提交了 4、5 次，折腾了快 2 个小时还是错误。后来用<code>git status</code>才发现是没有用<code>git add</code>对新建的文件添加跟踪，导致一直没能把这部分文件成功提交 😢</p><p>后来在看讨论区时，更是发现一篇精华帖的开头就用大写加粗强调了这个问题……</p><h1 id="exam-前准备"><a href="#exam-前准备" class="headerlink" title="exam 前准备"></a>exam 前准备</h1><h2 id="血泪教训"><a href="#血泪教训" class="headerlink" title="血泪教训"></a>血泪教训</h2><ul><li>在 bash 中，整个程序的返回值$?&#x3D;最后一条语句的返回值$?；且在评测机中一旦程序的返回值$?为 1，它就认为这个程序报错了；<br>故最好在每一个脚本文件末尾都手动写一个<code>exit 0</code><ul><li><code>$?</code>表示上一条语句的返回值；<code>$#</code>表示传参个数</li></ul></li></ul><h2 id="不熟操作"><a href="#不熟操作" class="headerlink" title="不熟操作"></a>不熟操作</h2><ul><li>输出 hello.c 中所有包含“os_hello”（区分大小写）的行的“os_hello”（区分大小写）以左的内容，如果一行出现多个，则输出第一次出现以左的部分<ul><li><code>grep</code> &amp; <code>sed</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;.*os_hello&#x27;</span> hello.c | sed -E <span class="string">&#x27;s/(.*)os_hello.*/\1/&#x27;</span></span><br></pre></td></tr></table></figure></li><li><code>awk</code> （两种均可）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;os_hello&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> hello.c</span><br><span class="line">awk <span class="string">&#x27;/os_hello/ &#123; sub(/os_hello.*/, &quot;&quot;); print &#125;&#x27;</span> hello.c</span><br></pre></td></tr></table></figure></li></ul></li><li><code>#var</code> 是获取变量的长度，<code>$&#123;#var&#125;</code>获取长度值</li><li><strong>字符串切片操作</strong><br><code>$&#123;variable:start:count&#125;</code> 表示从变量 <code>variable</code> 的 <code>start</code> 位置开始，截取 <code>count</code> 个字符</li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul><li>多层<code>if</code>容易忘记闭合<code>fi</code></li><li><code>&gt;&gt;</code> 追加会自动换行，想要不换行<code>echo-n xx &gt;&gt; xx</code></li><li><code>$?</code>返回值为 0 表示上一条命令执行成功，1 表示执行失败</li></ul><h1 id="exam-extra-复盘"><a href="#exam-extra-复盘" class="headerlink" title="exam &amp; extra 复盘"></a>exam &amp; extra 复盘</h1><h2 id="踩的坑（现场解决）"><a href="#踩的坑（现场解决）" class="headerlink" title="踩的坑（现场解决）"></a>踩的坑（现场解决）</h2><ul><li>编写脚本文件时，想要输出文件内容，不能用 more 要用 cat<ul><li>more 是交互式的命令，一般在终端直接使用</li></ul></li></ul><h2 id="知识漏洞（现场没解决）"><a href="#知识漏洞（现场没解决）" class="headerlink" title="知识漏洞（现场没解决）"></a>知识漏洞（现场没解决）</h2><ul><li><font color=blue>书写条件判断语句时注意！debug 时优先检查条件判断是否出错！</font><ul><li>less than，应该是<code>-lt</code> 不是 <code>-le</code> 🥲</li></ul></li></ul><h3 id="awk-用法补充"><a href="#awk-用法补充" class="headerlink" title="awk 用法补充"></a>awk 用法补充</h3><ul><li><strong>awk + if</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if($2==&quot;&#x27;</span><span class="variable">$PID</span><span class="string">&#x27;&quot;) print $3&#125;&#x27;</span> <span class="variable">$FILE</span></span><br></pre></td></tr></table></figure><ul><li><code>if</code> 语法和正常语法比较像，<code>if()</code> 后加空格，之后直接写命令（多为 <code>print</code> ）</li></ul></li><li><strong>在 awk 中使用在 shell 中定义的变量</strong><br>使用 <code>&quot;&#39;</code> 把 shell 变量包起来，即 <code>&quot;&#39;$var&#39;&quot;</code> ；注意是“<strong>双引号+单引号+shell 变量+单引号+双引号</strong>”的格式</li><li><strong>将 awk 结果赋值给变量</strong><br>使用倒引号，如 <code>var=`echo $result|awk &#39;&#123;print substr($result,16,3)&#125;&#39;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/googlea68f389f21ea577d.html"/>
      <url>/googlea68f389f21ea577d.html</url>
      
        <content type="html"><![CDATA[google-site-verification: googlea68f389f21ea577d.html]]></content>
      
    </entry>
    
    
  
</search>
